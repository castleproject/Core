<% @page_title = "PestControl" %>
<% @main_title = "PestControl" %>
<%= render "/sample/deflinks" %>

PestControl was created to serve as own-your-own-dog-food. It brought several 
issues to the light and as a consequence a lot of design decisions 
were proved wrong or right. Furtunatelly there are more successful cases than
otherwise. 

<p>
Few things that weren't planned also arise as benefits of the inversion
of control and Castle on Rails MVC design. We are glad to present them here.
</p>

<h3>What it is</h3>

<p>
PestControl is a build manager, in a nutshell. The flow is: you register
a project on it, the project has a source repository and a build system associated. 
Castle project, for instance, uses SVN and NAnt as source control and build system.
It should inspect the source control from time to time and fire a build 
when modifications are detected.
</p>

<p>
But the underlying intention is not to create this funcional application, 
in fact, the current alpha version allows you to create an account and
create a project. The intention is to use Castle to see whether it's going to 
improve your productivity or not. We're proud to say that it improved our
productivity, but we might be biased, so you should check for yourself. :-)
</p>

<p>
We list below a few things that were helpful and Windsor or Castle on Rails
provided for us.
</p>


<h3>Screenshots</h3>

<p>
Just to help you picture what this application is all about, 
see the following screenshots:
</p>

<p>
<a href="/images/sc1.png"><img border="0" src="/images/sc1-t.png" alt="Home"></a>
&nbsp;&nbsp;
<a href="/images/sc2.png"><img border="0" src="/images/sc2-t.png" alt="New Account"></a>
<br><br>
<a href="/images/sc3.png"><img border="0" src="/images/sc3-t.png" alt="New Project"></a>
&nbsp;&nbsp;
<a href="/images/sc4.png"><img border="0" src="/images/sc4-t.png" alt="New Project"></a>
<br><br>
<a href="/images/sc5.png"><img border="0" src="/images/sc5-t.png" alt="Dashboard"></a>
</p>


<h3>Prevalence Facility</h3>

<p>
There was no need to write code to set up the Prevalence Engine and 
Prevalence System. We just registered the facility and used the configuration 
file as the following snippet:
</p>

<pre class="source">

&lt;castle&gt;
  &lt;facilities&gt;
    &lt;facility id="prevalence"&gt;
      &lt;engines&gt;
        &lt;engine 
          id="prevalenceengine"
          autoVersionMigration="false" 
          storageDir="storage" 
          systemId="pestcontrolModel" 
 systemType="Castle.Applications.PestControl.Model.PestControlModel, 
       Castle.Applications.PestControl" /&gt;
      &lt;/engines&gt;
    &lt;/facility&gt;
  &lt;/facilities&gt;

&lt;/castle&gt;

</pre>

<p>
The facility then registered the engine with the 'prevalenceengine' key
and the system with the 'pestcontrolModel' key. Any component in the container
that has a constructor or a property with the system type or the prevalence engine
type were automatically assembled.
</p>

<p>
For the test cases, I used the other property in the engine node 
in the configuration: resetStorage='true', so everytime the engine starts, 
the storage was recreated.
</p>

<h3>Family of components</h3>

<p>
Within PestControl we have different components implementing
the same service interface. For example, we have a SvnSourceControl component
and a VssSourceControl and even a CvsSourceControl. Also, we have 
a NAntBuildSystem and a MSBuildBuildSystem. But how expose all of them to the user
and let him pick up one of each and associate with the project he's creating
on PestControl?
</p>

<p>
The solution was simple: a manager was registered, and this managed queries the
kernel for every component implementing a service. As a consequence, you can
add more source controls and more build system to the running application
 without the need to restart it.
</p>

<p>
Follows the BuildSystemManager code:
</p>

<pre class="source">
public class BuildSystemManager : IInitialize, IDisposable
{
	private IKernel _kernel;

	public BuildSystemManager(IKernel kernel)
	{
		_kernel = kernel;
	}

	public void Initialize()
	{
	}

	public void Dispose()
	{
		_kernel = null;
	}

	public virtual IBuildSystem[] AvailableBuildSystems()
	{
		ArrayList list = new ArrayList();

		IHandler[] handlers = _kernel.GetHandlers( 
			typeof(IBuildSystem) );

		foreach(IHandler handler in handlers)
		{
			list.Add( handler.Resolve() );
		}

		return (IBuildSystem[]) 
			list.ToArray( typeof(IBuildSystem) );
	}
}

</pre>

<h3>Application auto-assemble capability</h3>

<p>
The application code, even on the presentation layer,
became very straightforward, and the auto assemble simplified 
the classes code more than we expected. Here is a complex controller code:
</p>

<pre class="source">
[Transient]
public class ProjectController : SmartDispatcherController
{
	private PestControlModel _model;
	private SourceControlManager _scm;
	private BuildSystemManager _bsm;
	private PrevalenceEngine _engine;

	public ProjectController(
		PestControlModel model, PrevalenceEngine engine,
		SourceControlManager scm, BuildSystemManager bsm)
	{
		_engine = engine;
		_model = model;
		_scm = scm;
		_bsm = bsm;
	}

	public void New()
	{
		PropertyBag.Add("SourceControlManager", _scm);
		PropertyBag.Add("BuildSystemManager", _bsm);
	}

	public void Insert(String name, String bs, String sc)
	{
		bool isPublic = 
			(bool) PropertyBag["isPublic"];
		String ownerEmail = 
			(String) PropertyBag["ownerEmail"];
		Hashtable properties = 
			(Hashtable) PropertyBag["properties"];

		_engine.ExecuteCommand( 
			new CreateProjectCommand(
				isPublic, name, 
				sc, bs, ownerEmail, properties) );

		Redirect("dashboard", "index");
	}
}
</pre>

<p>
We only need to express what the controller needs using the
constructor, and everything else is up to the MicroKernel.
</p>

<h3>Controllers and PropertyBags</h3>

<p>
  The PropertyBag is a dictionary exposed by the controller instance. 
  Anything you put in the bag will try to find its way on the view. 
  You can also use the Bag to pass data from the view to the controller
  again. Follows some controller code:
</p>

<pre class="source">
	public void New()
	{
		PropertyBag.Add("SourceControlManager", _scm);
		PropertyBag.Add("BuildSystemManager", _bsm);
	}
</pre>

<p>
And here is the class (code behind) for a page associated:
</p>

<pre class="source">
public class New : System.Web.UI.Page
{
	private SourceControlManager _sourceControlManager;
	private BuildSystemManager _buildSystemManager;

	protected System.Web.UI.WebControls.Repeater dynRep;

	/// ...

	public SourceControlManager SourceControlManager
	{
		get { return _sourceControlManager; }
		set { _sourceControlManager = value; }
	}

	public BuildSystemManager BuildSystemManager
	{
		get { return _buildSystemManager; }
		set { _buildSystemManager = value; }
	}

	private void Page_Load(object sender, System.EventArgs e)
	{
		Save.Click += new EventHandler(OnSave);

		ISourceControl[] sourceControls = 
		  SourceControlManager.AvailableSourceControl();

		if (!IsPostBack)
		{
		  SelectedSourceControl = -1;

		  sc.AutoPostBack = true;
		  sc.DataSource = sourceControls;
		  sc.DataTextField = "Name";
		  sc.DataValueField = "Key";
		  sc.DataBind();

		  bs.DataSource = 
		    BuildSystemManager.AvailableBuildSystems();
		  bs.DataTextField = "Name";
		  bs.DataValueField = "Key";
		  bs.DataBind();
		}
	}
	
	/// ...
}

</pre>

<p>
The keys in the PropertyBag will be used to find the proper 
Property on the View class. Actually this is a implementation strategy
for the ASP.Net View Factory. If you create a NVelocity or other 
factory you can choose another strategy to expose the data 
to the view code.
</p>

<h3>The HttpApplication</h3>

<p>
We used the Global.asax to set up the container. Basically
the project Castle.Applications.PestControl exposes a container
which is nothing more than a subclass of WindsorContainer that
adds the components:
</p>

<pre class="source">
public class PestControlContainer : WindsorContainer
{  
  public PestControlContainer( 
    IConfigurationStore configStore ) : base()
  {
    Kernel.ConfigurationStore = configStore;

    AddFacility("prevalence", new PrevalenceFacility() );

    // BS Manager

    AddComponent("buildsystemmanager", 
        typeof(BuildSystemManager));

    // Build Systems

    AddComponent("nant", 
	    typeof(IBuildSystem), typeof(NAntBuildSystem));
    AddComponent("msbuild", 
	    typeof(IBuildSystem), typeof(MSBuildBuildSystem));

    // SC Manager

    AddComponent("sourcecontrolmanager", 
	    typeof(SourceControlManager));

    // Source Controls

    AddComponent("svnsc", 
	    typeof(ISourceControl), typeof(SvnSourceControl));
    AddComponent("cvssc", 
	    typeof(ISourceControl), typeof(CvsSourceControl));
    AddComponent("vsssc", 
	    typeof(ISourceControl), typeof(VssSourceControl));
    }
}
</pre>

<p>
Our Web Application (subclass of HttpApplication) adds the 
components related to the web presentation:
</p>

<pre class="source">
public class PestControlApplication : HttpApplication, 
	IContainerAccessor
{
	private static WindsorContainer container;

	public void Application_OnStart() 
	{
		container = new PestControlContainer( 
			new AppDomainConfigurationStore() );

		AddControllers(container);
	}

	private void AddControllers(WindsorContainer container)
	{
		container.AddComponent( "home", 
			typeof(HomeController) );
		container.AddComponent( "dashboard", 
			typeof(DashboardController) );
		container.AddComponent( "registration", 
			typeof(RegistrationController) );
		container.AddComponent( "project", 
			typeof(ProjectController) );
	}

	public void Application_OnEnd() 
	{
		container.Dispose();
	}

	public void FormsAuthentication_OnAuthenticate(
		Object sender, 
		FormsAuthenticationEventArgs e)
	{
		HttpCookie cookie = 
			e.Context.Request.Cookies[ 
			  FormsAuthentication.FormsCookieName ];

		if (cookie == null) return;

		FormsAuthenticationTicket ticket = 
		  FormsAuthentication.Decrypt(cookie.Value);

		PestControlModel model = (PestControlModel) 
			container[ typeof(PestControlModel) ];

		e.User = model.Users.FindByEmail( ticket.Name );
	}

	#region IContainerAccessor implementation

	public IWindsorContainer Container
	{
		get { return container; }
	}

	#endregion
}
</pre>

<h3>Conclusion</h3>

<p>
It seems that we are on the right track!
</p>

