<% @page_title = "Castle on Rails" %>
<% @subarea = "How to use" %>
<% @main_title = "How to use" %>
<%= render "/castleonrails/deflinks" %>

First of all, the idea of Castle on Rails is to have Controllers
to carry on the application logic and requesting data from the model 
(by dispatch these calls to the appropriate entities), and
use the view just as a presentation, without any logic different from 
the view logic. This is very different from how developers usually works
with ASP.Net.

<h3>Configuration</h3>

<p>
One of Castle's goals is to rely less on configuration files. Usually in MVC
frameworks you have to declare the controllers, views, models, and map their interaction.
With Castle on Rails you must only tell the framework which assembly has the controllers
and what's the base path for the views.
Optionally you can customize the factories used by the framework.
</p>

<p>

A simple web.config would be similar to the following:

<pre class="source">
&lt;configuration>

    &lt;configSections&gt;
        &lt;section name="rails"
type="Castle.CastleOnRails.Engine.Configuration.RailsSectionHandler,
Castle.CastleOnRails.Engine" /&gt;
    &lt;/configSections&gt;

    &lt;rails&gt;
		&lt;controllers assembly="AspnetSample" /&gt;
		&lt;views path="views" /&gt;
    &lt;/rails&gt;

    &lt;system.web&gt;
        &lt;httpHandlers&gt;
            &lt;add verb="*" path="*.rails" 
type="Castle.CastleOnRails.Engine.RailsHttpHandlerFactory, 
Castle.CastleOnRails.Engine" /&gt;
        &lt;/httpHandlers&gt;
    &lt;/system.web&gt;

&lt;/configuration&gt;
</pre>
</p>

<p>
So the rails configuration section tells the framework to inspect the assembly "AspnetSample"
for the controllers and that it must use the "views" physical directory as the base path for 
the views.
</p>

<p>
Please note that we are using the extension rails for the URLs, and the files do not exists
so please map the *.rails extension in IIS to ASP.Net ISAPI and do not check the option for
"check file exists".
</p>

<h3>The basic Controller</h3>

<p>
Currently the name of the controller is used in the URL, and the file name is the name of
the action the controller must expose. For example, the following URL:
</p>

<p>
<strong>http://www.myserver.com/home/index.rails</strong>
</p>

<p>
Will be transformed in an instatiantion of the controller HomeController and the invocation
of a public method index (case insensitive). The method must must exists, otherwise the framework
will throw an exception.
</p>

<p>
The controller can perform any action, and then direct the user to a specific view. If the controller
don't specify a view, the framework will look for a view in the view path named home\index (for this example).
The default engine is the ASP.Net engine, so the ViewFactory will look for a file index.aspx in the views\home
directory. 
</p>

<p>
The following is an example of a valid controller:
</p>

<pre class="source">
namespace AspnetSample.Controllers
{
	using System;

	using Castle.CastleOnRails.Framework;

	public class HomeController : Controller
	{
		public void Index()
		{
		}
	}
}
</pre>

<p>
The controller dispatch the user to a different view by using the 
RenderView method:
</p>

<pre class="source">
namespace AspnetSample.Controllers
{
	using System;

	using Castle.CastleOnRails.Framework;

	public class HomeController : Controller
	{
		public void Index()
		{
			RenderView("welcome");
		}
	}
}
</pre>

<p>
In this case, the engine will look for a file named welcome.aspx in the views\home directory.
</p>

<h3>A smarter Controller</h3>

<p>
Castle on Rails also exposes a smarter controller, named SmartDispatcherController.
This controller is just a specialization of the base Controller class to implement a better 
dispatch. In fact it maps the parameters in the get/post to method arguments. 
For example, the following URL:
</p>

<p>
<strong>http://.../registration/save.rails?name=hammett&pass-xpto</strong>
</p>

<p>
Would be mapped to a method Save that exposes arguments for name and password. 
Please note that the controller uses a heuristic to choose the method, so you can use method overload
and the controller will choose the method with more arguments that can be satified.
Basically it gives points to methods, for each argument that can be satisfied, it
adds more points, for arguments that cannot be matched, it subtract points. Finished this process it will
choose the method with more points.
</p>

<p>
The following is a sample usage:
</p>

<pre class="source">
public class Registration : SmartDispatcherController
{
	public void Index()
	{
	}

	public void Save(String name, 
		String address, String city, 
		String country, int age)
	{
		try
		{
		  // Inserting...
  		  RegistrationService.Insert(name, 
  		    address, city, country, age);

  		  // Done!
		  RenderView( "success" );
  		}
  		catch(BusinessException ex)
  		{
  		  // Whoops!
		  RenderView( "error" );
  		}
	}
}

</pre>

<h3>Using ASP.Net as the view layer</h3>

<p>
The default engine for view is ASP.Net. Why? Because ASP.Net is
also very effective and productive to write web applications. 
The reutilization and the controls lifecycle were really well done 
and very clever, so there is no point in trying to reinvent something similar.
</p>

<p>
There is nothing to be done to make ASP.Net work with Castle on Rails. 
Any ordinary .aspx will work. But in some cases you will use ASP.Net to 
show a form, gather and validate the input and then invoke a different action
in the controller. In this case your aspx must implement the IControllerAware
interface.
</p>

<p>
Before any complain, this is how MVC works. Layers in the MVC have a distinct and
well defined responsability. When developing with ASP.Net, usually each Page will 
have the role of controller, view and sometimes model. In a better design, the controller
needs to deal with business and application logic and flow, the view needs to 
handle presentation and validation of input, and the model will expose the data.
</p>

<p>
So, after your ASP.Net validates the input it can dispatch the current execution to a controller.
Follows an example of a code behind class:
</p>

<pre class="source"> 
public class index : System.Web.UI.Page, IControllerAware
{
	private Controller _controller;

    // implementation of IControllerAware
	public void SetController(Controller controller)
	{
		_controller = controller;
	}

	public void OnSave(object sender, EventArgs args)
	{
		// Validation
		// Work work work...
		// Ok, proceed

		_controller.Send( "Save" );
		
		Response.End();
	}
}
</pre>

<p>
The Response.End is used to avoid the current page to proceed its lifecycle. 
</p>


<h3>Windsor integration</h3>

<p>
As every subprojects of Castle Project, Castle on Rails can be used as a standalone 
application or you can use it together with the inversion of control container.
To do so, you only need to use a custom factory for controllers. So instead of inspecting 
an assembly, the Castle on Rails framework will ask the container for controllers.
</p>

<pre class="source">
&lt;configuration&gt;

    &lt;configSections&gt;
        &lt;section name="rails"
type="Castle.CastleOnRails.Engine.Configuration.RailsSectionHandler, 
Castle.CastleOnRails.Engine" /&gt;

        &lt;section name="castle"
type="Castle.Windsor.Configuration.AppDomain.CastleSectionHandler, 
Castle.Windsor" /&gt;
    &lt;/configSections&gt;

    &lt;rails&gt;
		&lt;views path="views" /&gt;
        &lt;customControllerFactory 
type="Castle.CastleOnRails.Engine.WindsorExtension.WindsorControllerFactory, 
Castle.CastleOnRails.Engine.WindsorExtension" /&gt;
    &lt;/rails&gt;

	&lt;castle&gt;
      ...Container configuration...
	&lt;/castle&gt;

    &lt;system.web&gt;
        &lt;httpHandlers&gt;
            &lt;add verb="*" path="*.rails" 
type="Castle.CastleOnRails.Engine.RailsHttpHandlerFactory, 
Castle.CastleOnRails.Engine" /&gt;
        &lt;/httpHandlers&gt;
    &lt;/system.web&gt;

&lt;/configuration&gt;
</pre>

<p>
Questions? Comments? Please join our mailing list.
</p>
