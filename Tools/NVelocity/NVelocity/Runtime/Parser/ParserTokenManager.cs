// Copyright 2004-2009 Castle Project - http://www.castleproject.org/
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


namespace NVelocity.Runtime.Parser
{
	using System;
	using System.Collections.Generic;
	using System.IO;
	using System.Text;

	/* Generated By:JJTree&JavaCC: Do not edit this line. ParserTokenManager.java */

	public class ParserTokenManager : ParserConstants
	{
		private int lparen = 0;
		private int rparen = 0;

		private Stack<Dictionary<string, int>> stateStack = new Stack<Dictionary<string, int>>();
		public bool debugPrint = false;

		public bool inDirective;
		private bool inComment;
		public bool inSet;

		/**
	 *  pushes the current state onto the 'state stack',
	 *  and maintains the parens counts
	 *  public because we need it in PD &amp; VM handling
	 *
	 *  @return bool : success.  It can fail if the state machine
	 *     gets messed up (do don't mess it up :)
	 */

		public bool StateStackPop()
		{
			Dictionary<string, int> h;

			try
			{
				h = stateStack.Pop();
			}
				// was EmptyStackException
			catch(InvalidOperationException)
			{
				lparen = 0;
				SwitchTo(DEFAULT);
				return false;
			}

			if (debugPrint)
				Console.Out.WriteLine(" stack pop ({0}) : lparen={1} newstate={2}", stateStack.Count, h["lparen"],
				                      h["lexstate"]);

			lparen = h["lparen"];
			rparen = h["rparen"];

			SwitchTo(h["lexstate"]);

			return true;
		}

		/**
	 *  pops a state off the stack, and restores paren counts
	 *
	 *  @return bool : success of operation
	 */

		public bool StateStackPush()
		{
			if (debugPrint)
				Console.Out.WriteLine(" ({0}) pushing cur state : {1}", stateStack.Count, curLexState);

			Dictionary<string, int> h = new Dictionary<string, int>();

			h.Add("lexstate", curLexState);
			h.Add("lparen", lparen);
			h.Add("rparen", rparen);

			lparen = 0;

			stateStack.Push(h);

			return true;
		}

		/**
	 *  Clears all state variables, resets to
	 *  start values, clears stateStack.  Call
	 *  before parsing.
	 *  @return void
	 */

		public void ClearStateVars()
		{
			stateStack.Clear();

			lparen = 0;
			rparen = 0;
			inDirective = false;
			inComment = false;
			inSet = false;

			return;
		}


		/**
	 *  handles the dropdown logic when encountering a RPAREN
	 */

		private void RPARENHandler()
		{
			/*
	     *  Ultimately, we want to drop down to the state below 
	     *  the one that has an open (if we hit bottom (DEFAULT), 
	     *  that's fine. It's just text schmoo.
	     */

			bool closed = false;

			if (inComment)
				closed = true;

			while(!closed)
			{
				/*
		 * look at current state.  If we haven't seen a lparen 
		 * in this state then we drop a state, because this 
		 * lparen clearly closes our state
		 */

				if (lparen > 0)
				{
					/*
		     *  if rparen + 1 == lparen, then this state is closed. 
		     * Otherwise, increment and keep parsing
		     */

					if (lparen == rparen + 1)
					{
						StateStackPop();
					}
					else
					{
						rparen++;
					}

					closed = true;
				}
				else
				{
					/*
		     * now, drop a state
		     */

					if (!StateStackPop())
						break;
				}
			}
		}

		public TextWriter debugStream = Console.Out;

		public void SetDebugStream(StreamWriter ds)
		{
			debugStream = ds;
		}

		private int jjStopStringLiteralDfa_0(int pos, long active0)
		{
			switch(pos)
			{
				case 0:
					if ((active0 & 0x6000000L) != 0L)
					{
						jjmatchedKind = 52;
						return 33;
					}
					if ((active0 & 0x10000000L) != 0L)
						return 31;
					if ((active0 & 0xd000L) != 0L)
						return 7;
					return -1;
				case 1:
					if ((active0 & 0x6000000L) != 0L)
					{
						jjmatchedKind = 52;
						jjmatchedPos = 1;
						return 33;
					}
					if ((active0 & 0x4000L) != 0L)
						return 5;
					return -1;
				case 2:
					if ((active0 & 0x6000000L) != 0L)
					{
						jjmatchedKind = 52;
						jjmatchedPos = 2;
						return 33;
					}
					return -1;
				case 3:
					if ((active0 & 0x4000000L) != 0L)
					{
						jjmatchedKind = 52;
						jjmatchedPos = 3;
						return 33;
					}
					if ((active0 & 0x2000000L) != 0L)
						return 33;
					return -1;
				default:
					return -1;
			}
		}

		private int jjStartNfa_0(int pos, long active0)
		{
			return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
		}

		private int jjStopAtPos(int pos, int kind)
		{
			jjmatchedKind = kind;
			jjmatchedPos = pos;
			return pos + 1;
		}

		private int jjStartNfaWithStates_0(int pos, int kind, int state)
		{
			jjmatchedKind = kind;
			jjmatchedPos = pos;
			if (!input_stream.ReadChar())
			{
				return pos + 1;
			}
			return jjMoveNfa_0(state, pos + 1);
		}

		private int jjMoveStringLiteralDfa0_0()
		{
			switch(input_stream.CurrentCharacter)
			{
				case (char) 33:
					jjmatchedKind = 41;
					return jjMoveStringLiteralDfa1_0(0x10000000000L);
				case (char) 35:
					jjmatchedKind = 15;
					return jjMoveStringLiteralDfa1_0(0x5000L);
				case (char) 37:
					return jjStopAtPos(0, 32);
				case (char) 38:
					return jjMoveStringLiteralDfa1_0(0x200000000L);
				case (char) 40:
					return jjStopAtPos(0, 5);
				case (char) 42:
					return jjStopAtPos(0, 30);
				case (char) 43:
					return jjStopAtPos(0, 29);
				case (char) 44:
					return jjStopAtPos(0, 3);
				case (char) 45:
					return jjStartNfaWithStates_0(0, 28, 31);
				case (char) 46:
					return jjMoveStringLiteralDfa1_0(0x10L);
				case (char) 47:
					return jjStopAtPos(0, 31);
				case (char) 60:
					jjmatchedKind = 35;
					return jjMoveStringLiteralDfa1_0(0x1000000000L);
				case (char) 61:
					jjmatchedKind = 42;
					return jjMoveStringLiteralDfa1_0(0x8000000000L);
				case (char) 62:
					jjmatchedKind = 37;
					return jjMoveStringLiteralDfa1_0(0x4000000000L);
				case (char) 91:
					return jjStopAtPos(0, 1);
				case (char) 93:
					return jjStopAtPos(0, 2);
				case (char) 102:
					return jjMoveStringLiteralDfa1_0(0x4000000L);
				case (char) 116:
					return jjMoveStringLiteralDfa1_0(0x2000000L);
				case (char) 124:
					return jjMoveStringLiteralDfa1_0(0x400000000L);
				default:
					return jjMoveNfa_0(0, 0);
			}
		}

		private int jjMoveStringLiteralDfa1_0(long active0)
		{
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_0(0, active0);
				return 1;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					if ((active0 & 0x1000L) != 0L)
						return jjStopAtPos(1, 12);
					break;
				case (char) 38:
					if ((active0 & 0x200000000L) != 0L)
						return jjStopAtPos(1, 33);
					break;
				case (char) 42:
					if ((active0 & 0x4000L) != 0L)
						return jjStartNfaWithStates_0(1, 14, 5);
					break;
				case (char) 46:
					if ((active0 & 0x10L) != 0L)
						return jjStopAtPos(1, 4);
					break;
				case (char) 61:
					if ((active0 & 0x1000000000L) != 0L)
						return jjStopAtPos(1, 36);
					else if ((active0 & 0x4000000000L) != 0L)
						return jjStopAtPos(1, 38);
					else if ((active0 & 0x8000000000L) != 0L)
						return jjStopAtPos(1, 39);
					else if ((active0 & 0x10000000000L) != 0L)
						return jjStopAtPos(1, 40);
					break;
				case (char) 97:
					return jjMoveStringLiteralDfa2_0(active0, 0x4000000L);
				case (char) 114:
					return jjMoveStringLiteralDfa2_0(active0, 0x2000000L);
				case (char) 124:
					if ((active0 & 0x400000000L) != 0L)
						return jjStopAtPos(1, 34);
					break;
				default:
					break;
			}
			return jjStartNfa_0(0, active0);
		}

		private int jjMoveStringLiteralDfa2_0(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_0(0, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_0(1, active0);
				return 2;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 108:
					return jjMoveStringLiteralDfa3_0(active0, 0x4000000L);
				case (char) 117:
					return jjMoveStringLiteralDfa3_0(active0, 0x2000000L);
				default:
					break;
			}
			return jjStartNfa_0(1, active0);
		}

		private int jjMoveStringLiteralDfa3_0(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_0(1, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_0(2, active0);
				return 3;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 101:
					if ((active0 & 0x2000000L) != 0L)
						return jjStartNfaWithStates_0(3, 25, 33);
					break;
				case (char) 115:
					return jjMoveStringLiteralDfa4_0(active0, 0x4000000L);
				default:
					break;
			}
			return jjStartNfa_0(2, active0);
		}

		private int jjMoveStringLiteralDfa4_0(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_0(2, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_0(3, active0);
				return 4;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 101:
					if ((active0 & 0x4000000L) != 0L)
						return jjStartNfaWithStates_0(4, 26, 33);
					break;
				default:
					break;
			}
			return jjStartNfa_0(3, active0);
		}

		private void jjCheckNAdd(int state)
		{
			if (jjrounds[state] != jjround)
			{
				jjstateSet[jjnewStateCnt++] = (uint) state;
				jjrounds[state] = jjround;
			}
		}

		private void jjAddStates(int start, int end)
		{
			do
			{
				jjstateSet[jjnewStateCnt++] = (uint) jjnextStates[start];
			} while(start++ != end);
		}

		private void jjCheckNAddTwoStates(int state1, int state2)
		{
			jjCheckNAdd(state1);
			jjCheckNAdd(state2);
		}

		private void jjCheckNAddStates(int start, int end)
		{
			do
			{
				jjCheckNAdd(jjnextStates[start]);
			} while(start++ != end);
		}


		private static ulong[] jjbitVec0 = {
		                                   	0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
		                                   };

		private static ulong[] jjbitVec2 = {
		                                   	0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
		                                   };

		private int jjMoveNfa_0(int startState, int curPos)
		{
			int startsAt = 0;
			jjnewStateCnt = 42;
			int i = 1;
			jjstateSet[0] = (uint) startState;
			int kind = 0x7fffffff;
			for(;;)
			{
				if (++jjround == 0x7fffffff)
					ReInitRounds();
				char character = input_stream.CurrentCharacter;
				if (character < 64)
				{
					long l = 1L << character;
					do
					{
						switch(jjstateSet[--i])
						{
							case 0:
								if ((0x3ff000000000000L & l) != 0L)
								{
									if (kind > 49)
										kind = 49;
									jjCheckNAdd(31);
								}
								else if ((0x2400L & l) != 0L)
								{
									if (kind > 27)
										kind = 27;
								}
								else if ((0x100000200L & l) != 0L)
								{
									if (kind > 23)
										kind = 23;
									jjCheckNAdd(9);
								}
								else if (character == 36)
								{
									if (kind > 10)
										kind = 10;
									jjCheckNAddTwoStates(39, 40);
								}
								else if (character == 45)
									jjCheckNAdd(31);
								else if (character == 39)
									jjCheckNAddStates(0, 2);
								else if (character == 34)
									jjCheckNAddStates(3, 5);
								else if (character == 35)
									jjstateSet[jjnewStateCnt++] = 7;
								else if (character == 41)
								{
									if (kind > 6)
										kind = 6;
									jjCheckNAddStates(6, 8);
								}
								if (character == 13)
									jjstateSet[jjnewStateCnt++] = 28;
								break;
							case 1:
								if ((0x100000200L & l) != 0L)
									jjCheckNAddStates(6, 8);
								break;
							case 2:
								if ((0x2400L & l) != 0L && kind > 6)
									kind = 6;
								break;
							case 3:
								if (character == 10 && kind > 6)
									kind = 6;
								break;
							case 4:
								if (character == 13)
									jjstateSet[jjnewStateCnt++] = 3;
								break;
							case 5:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 6;
								break;
							case 6:
								if ((0xfffffff7ffffffffUL & (ulong) l) != 0L && kind > 13)
									kind = 13;
								break;
							case 7:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 5;
								break;
							case 8:
								if (character == 35)
									jjstateSet[jjnewStateCnt++] = 7;
								break;
							case 9:
								if ((0x100000200L & l) == 0L)
									break;
								if (kind > 23)
									kind = 23;
								jjCheckNAdd(9);
								break;
							case 10:
								if (character == 34)
									jjCheckNAddStates(3, 5);
								break;
							case 11:
								if ((0xfffffffbffffdbffUL & (ulong) l) != 0L)
									jjCheckNAddStates(3, 5);
								break;
							case 12:
								if (character == 34 && kind > 24)
									kind = 24;
								break;
							case 14:
								if ((0x8400000000L & l) != 0L)
									jjCheckNAddStates(3, 5);
								break;
							case 15:
								if ((0xff000000000000L & l) != 0L)
									jjCheckNAddStates(9, 12);
								break;
							case 16:
								if ((0xff000000000000L & l) != 0L)
									jjCheckNAddStates(3, 5);
								break;
							case 17:
								if ((0xf000000000000L & l) != 0L)
									jjstateSet[jjnewStateCnt++] = 18;
								break;
							case 18:
								if ((0xff000000000000L & l) != 0L)
									jjCheckNAdd(16);
								break;
							case 19:
								if (character == 32)
									jjAddStates(13, 14);
								break;
							case 20:
								if (character == 10)
									jjCheckNAddStates(3, 5);
								break;
							case 21:
								if (character == 39)
									jjCheckNAddStates(0, 2);
								break;
							case 22:
								if ((0xffffff7fffffdbffUL & (ulong) l) != 0L)
									jjCheckNAddStates(0, 2);
								break;
							case 24:
								if (character == 32)
									jjAddStates(15, 16);
								break;
							case 25:
								if (character == 10)
									jjCheckNAddStates(0, 2);
								break;
							case 26:
								if (character == 39 && kind > 24)
									kind = 24;
								break;
							case 27:
								if ((0x2400L & l) != 0L && kind > 27)
									kind = 27;
								break;
							case 28:
								if (character == 10 && kind > 27)
									kind = 27;
								break;
							case 29:
								if (character == 13)
									jjstateSet[jjnewStateCnt++] = 28;
								break;
							case 30:
								if (character == 45)
									jjCheckNAdd(31);
								break;
							case 31:
								if ((0x3ff000000000000L & l) == 0L)
									break;
								if (kind > 49)
									kind = 49;
								jjCheckNAdd(31);
								break;
							case 33:
								if ((0x3ff000000000000L & l) == 0L)
									break;
								if (kind > 52)
									kind = 52;
								jjstateSet[jjnewStateCnt++] = 33;
								break;
							case 36:
								if (character == 36 && kind > 10)
									kind = 10;
								break;
							case 38:
								if (character == 36)
									jjCheckNAddTwoStates(39, 40);
								break;
							case 40:
								if (character == 33 && kind > 11)
									kind = 11;
								break;
							case 41:
								if (character != 36)
									break;
								if (kind > 10)
									kind = 10;
								jjCheckNAddTwoStates(39, 40);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else if (character < 128)
				{
					long l = 1L << (character & 63);
					do
					{
						switch(jjstateSet[--i])
						{
							case 0:
								if ((0x7fffffe87fffffeL & l) != 0L)
								{
									if (kind > 52)
										kind = 52;
									jjCheckNAdd(33);
								}
								else if (character == 92)
									jjCheckNAddStates(17, 20);
								break;
							case 6:
								if (kind > 13)
									kind = 13;
								break;
							case 11:
								if ((0xffffffffefffffffUL & (ulong) l) != 0L)
									jjCheckNAddStates(3, 5);
								break;
							case 13:
								if (character == 92)
									jjAddStates(21, 25);
								break;
							case 14:
								if ((0x14404410000000L & l) != 0L)
									jjCheckNAddStates(3, 5);
								break;
							case 22:
								jjAddStates(0, 2);
								break;
							case 23:
								if (character == 92)
									jjAddStates(15, 16);
								break;
							case 32:
							case 33:
								if ((0x7fffffe87fffffeL & l) == 0L)
									break;
								if (kind > 52)
									kind = 52;
								jjCheckNAdd(33);
								break;
							case 34:
								if (character == 92)
									jjCheckNAddStates(17, 20);
								break;
							case 35:
								if (character == 92)
									jjCheckNAddTwoStates(35, 36);
								break;
							case 37:
								if (character == 92)
									jjCheckNAddTwoStates(37, 38);
								break;
							case 39:
								if (character == 92)
									jjAddStates(26, 27);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else
				{
					int hiByte = character >> 8;
					int i1 = hiByte >> 6;
					long l1 = 1L << (hiByte & 63);
					int i2 = (character & 0xff) >> 6;
					long l2 = 1L << (character & 63);
					do
					{
						switch(jjstateSet[--i])
						{
							case 6:
								if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
									kind = 13;
								break;
							case 11:
								if (jjCanMove_0(hiByte, i1, i2, l1, l2))
									jjAddStates(3, 5);
								break;
							case 22:
								if (jjCanMove_0(hiByte, i1, i2, l1, l2))
									jjAddStates(0, 2);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				if (kind != 0x7fffffff)
				{
					jjmatchedKind = kind;
					jjmatchedPos = curPos;
					kind = 0x7fffffff;
				}
				++curPos;
				if ((i = jjnewStateCnt) == (startsAt = 42 - (jjnewStateCnt = startsAt)))
					return curPos;
				if (!input_stream.ReadChar())
				{
					return curPos;
				}
			}
		}

		private int jjStopStringLiteralDfa_6(int pos, long active0)
		{
			switch(pos)
			{
				case 0:
					if ((active0 & 0xd000L) != 0L)
						return 2;
					return -1;
				default:
					return -1;
			}
		}

		private int jjStartNfa_6(int pos, long active0)
		{
			return jjMoveNfa_6(jjStopStringLiteralDfa_6(pos, active0), pos + 1);
		}

		private int jjStartNfaWithStates_6(int pos, int kind, int state)
		{
			jjmatchedKind = kind;
			jjmatchedPos = pos;
			if (!input_stream.ReadChar())
			{
				return pos + 1;
			}
			return jjMoveNfa_6(state, pos + 1);
		}

		private int jjMoveStringLiteralDfa0_6()
		{
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					jjmatchedKind = 15;
					return jjMoveStringLiteralDfa1_6(0x5000L);
				case (char) 42:
					return jjMoveStringLiteralDfa1_6(0x200000L);
				default:
					return jjMoveNfa_6(3, 0);
			}
		}

		private int jjMoveStringLiteralDfa1_6(long active0)
		{
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_6(0, active0);
				return 1;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					if ((active0 & 0x1000L) != 0L)
						return jjStopAtPos(1, 12);
					else if ((active0 & 0x200000L) != 0L)
						return jjStopAtPos(1, 21);
					break;
				case (char) 42:
					if ((active0 & 0x4000L) != 0L)
						return jjStartNfaWithStates_6(1, 14, 0);
					break;
				default:
					break;
			}
			return jjStartNfa_6(0, active0);
		}

		private int jjMoveNfa_6(int startState, int curPos)
		{
			int startsAt = 0;
			jjnewStateCnt = 12;
			int i = 1;
			jjstateSet[0] = (uint) startState;
			int kind = 0x7fffffff;
			for(;;)
			{
				if (++jjround == 0x7fffffff)
					ReInitRounds();
				char character = input_stream.CurrentCharacter;
				if (character < 64)
				{
					long l = 1L << character;
					do
					{
						switch(jjstateSet[--i])
						{
							case 3:
								if (character == 36)
								{
									if (kind > 10)
										kind = 10;
									jjCheckNAddTwoStates(9, 10);
								}
								else if (character == 35)
									jjstateSet[jjnewStateCnt++] = 2;
								break;
							case 0:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 1;
								break;
							case 1:
								if ((0xfffffff7ffffffffUL & (ulong) l) != 0L && kind > 13)
									kind = 13;
								break;
							case 2:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 0;
								break;
							case 6:
								if (character == 36 && kind > 10)
									kind = 10;
								break;
							case 8:
								if (character == 36)
									jjCheckNAddTwoStates(9, 10);
								break;
							case 10:
								if (character == 33 && kind > 11)
									kind = 11;
								break;
							case 11:
								if (character != 36)
									break;
								if (kind > 10)
									kind = 10;
								jjCheckNAddTwoStates(9, 10);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else if (character < 128)
				{
					do
					{
						switch(jjstateSet[--i])
						{
							case 3:
								if (character == 92)
									jjCheckNAddStates(28, 31);
								break;
							case 1:
								if (kind > 13)
									kind = 13;
								break;
							case 5:
								if (character == 92)
									jjCheckNAddTwoStates(5, 6);
								break;
							case 7:
								if (character == 92)
									jjCheckNAddTwoStates(7, 8);
								break;
							case 9:
								if (character == 92)
									jjAddStates(32, 33);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else
				{
					int hiByte = (character >> 8);
					int i1 = hiByte >> 6;
					long l1 = 1L << (hiByte & 63);
					int i2 = (character & 0xff) >> 6;
					long l2 = 1L << (character & 63);
					do
					{
						switch(jjstateSet[--i])
						{
							case 1:
								if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
									kind = 13;
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				if (kind != 0x7fffffff)
				{
					jjmatchedKind = kind;
					jjmatchedPos = curPos;
					kind = 0x7fffffff;
				}
				++curPos;
				if ((i = jjnewStateCnt) == (startsAt = 12 - (jjnewStateCnt = startsAt)))
					return curPos;
				if (!input_stream.ReadChar())
				{
					return curPos;
				}
			}
		}

		private int jjStopStringLiteralDfa_4(int pos, long active0)
		{
			switch(pos)
			{
				case 0:
					if ((active0 & 0xd000L) != 0L)
						return 2;
					if ((active0 & 0x200000000000L) != 0L)
					{
						jjmatchedKind = 52;
						return 22;
					}
					if ((active0 & 0x900000000000L) != 0L)
					{
						jjmatchedKind = 52;
						return 7;
					}
					return -1;
				case 1:
					if ((active0 & 0x4000L) != 0L)
						return 0;
					if ((active0 & 0x200000000000L) != 0L)
					{
						jjmatchedKind = 52;
						jjmatchedPos = 1;
						return 28;
					}
					if ((active0 & 0x800000000000L) != 0L)
					{
						jjmatchedKind = 52;
						jjmatchedPos = 1;
						return 7;
					}
					if ((active0 & 0x100000000000L) != 0L)
						return 7;
					return -1;
				case 2:
					if ((active0 & 0x200000000000L) != 0L)
					{
						jjmatchedKind = 52;
						jjmatchedPos = 2;
						return 23;
					}
					if ((active0 & 0x800000000000L) != 0L)
					{
						jjmatchedKind = 52;
						jjmatchedPos = 2;
						return 7;
					}
					return -1;
				case 3:
					if ((active0 & 0x800000000000L) != 0L)
						return 7;
					if ((active0 & 0x200000000000L) != 0L)
					{
						jjmatchedKind = 46;
						jjmatchedPos = 3;
						return 30;
					}
					return -1;
				case 4:
					if ((active0 & 0x200000000000L) != 0L)
					{
						jjmatchedKind = 52;
						jjmatchedPos = 4;
						return 7;
					}
					return -1;
				default:
					return -1;
			}
		}

		private int jjStartNfa_4(int pos, long active0)
		{
			return jjMoveNfa_4(jjStopStringLiteralDfa_4(pos, active0), pos + 1);
		}

		private int jjStartNfaWithStates_4(int pos, int kind, int state)
		{
			jjmatchedKind = kind;
			jjmatchedPos = pos;
			if (!input_stream.ReadChar())
			{
				return pos + 1;
			}
			return jjMoveNfa_4(state, pos + 1);
		}

		private int jjMoveStringLiteralDfa0_4()
		{
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					jjmatchedKind = 15;
					return jjMoveStringLiteralDfa1_4(0x5000L);
				case (char) 101:
					return jjMoveStringLiteralDfa1_4(0x200000000000L);
				case (char) 105:
					return jjMoveStringLiteralDfa1_4(0x100000000000L);
				case (char) 115:
					return jjMoveStringLiteralDfa1_4(0x800000000000L);
				default:
					return jjMoveNfa_4(3, 0);
			}
		}

		private int jjMoveStringLiteralDfa1_4(long active0)
		{
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_4(0, active0);
				return 1;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					if ((active0 & 0x1000L) != 0L)
						return jjStopAtPos(1, 12);
					break;
				case (char) 42:
					if ((active0 & 0x4000L) != 0L)
						return jjStartNfaWithStates_4(1, 14, 0);
					break;
				case (char) 102:
					if ((active0 & 0x100000000000L) != 0L)
						return jjStartNfaWithStates_4(1, 44, 7);
					break;
				case (char) 108:
					return jjMoveStringLiteralDfa2_4(active0, 0x200000000000L);
				case (char) 116:
					return jjMoveStringLiteralDfa2_4(active0, 0x800000000000L);
				default:
					break;
			}
			return jjStartNfa_4(0, active0);
		}

		private int jjMoveStringLiteralDfa2_4(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_4(0, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_4(1, active0);
				return 2;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 111:
					return jjMoveStringLiteralDfa3_4(active0, 0x800000000000L);
				case (char) 115:
					return jjMoveStringLiteralDfa3_4(active0, 0x200000000000L);
				default:
					break;
			}
			return jjStartNfa_4(1, active0);
		}

		private int jjMoveStringLiteralDfa3_4(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_4(1, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_4(2, active0);
				return 3;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 101:
					return jjMoveStringLiteralDfa4_4(active0, 0x200000000000L);
				case (char) 112:
					if ((active0 & 0x800000000000L) != 0L)
						return jjStartNfaWithStates_4(3, 47, 7);
					break;
				default:
					break;
			}
			return jjStartNfa_4(2, active0);
		}

		private int jjMoveStringLiteralDfa4_4(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_4(2, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_4(3, active0);
				return 4;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 105:
					return jjMoveStringLiteralDfa5_4(active0, 0x200000000000L);
				default:
					break;
			}
			return jjStartNfa_4(3, active0);
		}

		private int jjMoveStringLiteralDfa5_4(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_4(3, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_4(4, active0);
				return 5;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 102:
					if ((active0 & 0x200000000000L) != 0L)
						return jjStartNfaWithStates_4(5, 45, 7);
					break;
				default:
					break;
			}
			return jjStartNfa_4(4, active0);
		}

		private int jjMoveNfa_4(int startState, int curPos)
		{
			int startsAt = 0;
			jjnewStateCnt = 30;
			int i = 1;
			jjstateSet[0] = (uint) startState;
			int kind = 0x7fffffff;
			for(;;)
			{
				if (++jjround == 0x7fffffff)
					ReInitRounds();
				char character = input_stream.CurrentCharacter;
				if (character < 64)
				{
					long l = 1L << character;
					do
					{
						switch(jjstateSet[--i])
						{
							case 3:
								if ((0x3ff000000000000L & l) != 0L)
								{
									if (kind > 49)
										kind = 49;
									jjCheckNAdd(5);
								}
								else if (character == 36)
								{
									if (kind > 10)
										kind = 10;
									jjCheckNAddTwoStates(13, 14);
								}
								else if (character == 45)
									jjCheckNAdd(5);
								else if (character == 35)
									jjstateSet[jjnewStateCnt++] = 2;
								break;
							case 30:
								if ((0x3ff000000000000L & l) != 0L)
								{
									if (kind > 52)
										kind = 52;
									jjCheckNAdd(7);
								}
								else if ((0x2400L & l) != 0L)
								{
									if (kind > 46)
										kind = 46;
								}
								else if ((0x100000200L & l) != 0L)
									jjCheckNAddStates(34, 36);
								if (character == 13)
									jjstateSet[jjnewStateCnt++] = 26;
								break;
							case 22:
							case 7:
								if ((0x3ff000000000000L & l) == 0L)
									break;
								if (kind > 52)
									kind = 52;
								jjCheckNAdd(7);
								break;
							case 28:
								if ((0x3ff000000000000L & l) == 0L)
									break;
								if (kind > 52)
									kind = 52;
								jjCheckNAdd(7);
								break;
							case 23:
								if ((0x3ff000000000000L & l) == 0L)
									break;
								if (kind > 52)
									kind = 52;
								jjCheckNAdd(7);
								break;
							case 0:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 1;
								break;
							case 1:
								if ((0xfffffff7ffffffffUL & (ulong) l) != 0L && kind > 13)
									kind = 13;
								break;
							case 2:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 0;
								break;
							case 4:
								if (character == 45)
									jjCheckNAdd(5);
								break;
							case 5:
								if ((0x3ff000000000000L & l) == 0L)
									break;
								if (kind > 49)
									kind = 49;
								jjCheckNAdd(5);
								break;
							case 10:
								if (character == 36 && kind > 10)
									kind = 10;
								break;
							case 12:
								if (character == 36)
									jjCheckNAddTwoStates(13, 14);
								break;
							case 14:
								if (character == 33 && kind > 11)
									kind = 11;
								break;
							case 15:
								if (character != 36)
									break;
								if (kind > 10)
									kind = 10;
								jjCheckNAddTwoStates(13, 14);
								break;
							case 18:
								if ((0x100000200L & l) != 0L)
									jjAddStates(37, 39);
								break;
							case 19:
								if ((0x2400L & l) != 0L && kind > 43)
									kind = 43;
								break;
							case 20:
								if (character == 10 && kind > 43)
									kind = 43;
								break;
							case 21:
								if (character == 13)
									jjstateSet[jjnewStateCnt++] = 20;
								break;
							case 24:
								if ((0x100000200L & l) != 0L)
									jjCheckNAddStates(34, 36);
								break;
							case 25:
								if ((0x2400L & l) != 0L && kind > 46)
									kind = 46;
								break;
							case 26:
								if (character == 10 && kind > 46)
									kind = 46;
								break;
							case 27:
								if (character == 13)
									jjstateSet[jjnewStateCnt++] = 26;
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else if (character < 128)
				{
					long l = 1L << (character & 63);
					do
					{
						switch(jjstateSet[--i])
						{
							case 3:
								if ((0x7fffffe87fffffeL & l) != 0L)
								{
									if (kind > 52)
										kind = 52;
									jjCheckNAdd(7);
								}
								else if (character == 92)
									jjCheckNAddStates(40, 43);
								if (character == 101)
									jjAddStates(44, 45);
								break;
							case 30:
							case 7:
								if ((0x7fffffe87fffffeL & l) == 0L)
									break;
								if (kind > 52)
									kind = 52;
								jjCheckNAdd(7);
								break;
							case 22:
								if ((0x7fffffe87fffffeL & l) != 0L)
								{
									if (kind > 52)
										kind = 52;
									jjCheckNAdd(7);
								}
								if (character == 108)
									jjstateSet[jjnewStateCnt++] = 28;
								else if (character == 110)
									jjstateSet[jjnewStateCnt++] = 17;
								break;
							case 28:
								if ((0x7fffffe87fffffeL & l) != 0L)
								{
									if (kind > 52)
										kind = 52;
									jjCheckNAdd(7);
								}
								if (character == 115)
									jjstateSet[jjnewStateCnt++] = 23;
								break;
							case 23:
								if ((0x7fffffe87fffffeL & l) != 0L)
								{
									if (kind > 52)
										kind = 52;
									jjCheckNAdd(7);
								}
								if (character == 101)
								{
									if (kind > 46)
										kind = 46;
									jjAddStates(34, 36);
								}
								break;
							case 1:
								if (kind > 13)
									kind = 13;
								break;
							case 6:
								if ((0x7fffffe87fffffeL & l) == 0L)
									break;
								if (kind > 52)
									kind = 52;
								jjCheckNAdd(7);
								break;
							case 8:
								if (character == 92)
									jjCheckNAddStates(40, 43);
								break;
							case 9:
								if (character == 92)
									jjCheckNAddTwoStates(9, 10);
								break;
							case 11:
								if (character == 92)
									jjCheckNAddTwoStates(11, 12);
								break;
							case 13:
								if (character == 92)
									jjAddStates(46, 47);
								break;
							case 16:
								if (character == 101)
									jjAddStates(44, 45);
								break;
							case 17:
								if (character != 100)
									break;
								if (kind > 43)
									kind = 43;
								jjAddStates(37, 39);
								break;
							case 29:
								if (character == 108)
									jjstateSet[jjnewStateCnt++] = 28;
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else
				{
					int hiByte = (character >> 8);
					int i1 = hiByte >> 6;
					long l1 = 1L << (hiByte & 63);
					int i2 = (character & 0xff) >> 6;
					long l2 = 1L << (character & 63);
					do
					{
						switch(jjstateSet[--i])
						{
							case 1:
								if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
									kind = 13;
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				if (kind != 0x7fffffff)
				{
					jjmatchedKind = kind;
					jjmatchedPos = curPos;
					kind = 0x7fffffff;
				}
				++curPos;
				if ((i = jjnewStateCnt) == (startsAt = 30 - (jjnewStateCnt = startsAt)))
					return curPos;
				if (!input_stream.ReadChar())
				{
					return curPos;
				}
			}
		}

		private int jjStopStringLiteralDfa_3(int pos, long active0)
		{
			switch(pos)
			{
				case 0:
					if ((active0 & 0x30000L) != 0L)
						return 7;
					if ((active0 & 0xd000L) != 0L)
						return 14;
					return -1;
				default:
					return -1;
			}
		}

		private int jjStartNfa_3(int pos, long active0)
		{
			return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1);
		}

		private int jjStartNfaWithStates_3(int pos, int kind, int state)
		{
			jjmatchedKind = kind;
			jjmatchedPos = pos;
			if (!input_stream.ReadChar())
			{
				return pos + 1;
			}
			return jjMoveNfa_3(state, pos + 1);
		}

		private int jjMoveStringLiteralDfa0_3()
		{
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					jjmatchedKind = 15;
					return jjMoveStringLiteralDfa1_3(0x5000L);
				case (char) 92:
					jjmatchedKind = 17;
					return jjMoveStringLiteralDfa1_3(0x10000L);
				default:
					return jjMoveNfa_3(11, 0);
			}
		}

		private int jjMoveStringLiteralDfa1_3(long active0)
		{
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_3(0, active0);
				return 1;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					if ((active0 & 0x1000L) != 0L)
						return jjStopAtPos(1, 12);
					break;
				case (char) 42:
					if ((active0 & 0x4000L) != 0L)
						return jjStartNfaWithStates_3(1, 14, 12);
					break;
				case (char) 92:
					if ((active0 & 0x10000L) != 0L)
						return jjStartNfaWithStates_3(1, 16, 23);
					break;
				default:
					break;
			}
			return jjStartNfa_3(0, active0);
		}

		private int jjMoveNfa_3(int startState, int curPos)
		{
			int startsAt = 0;
			jjnewStateCnt = 23;
			int i = 1;
			jjstateSet[0] = (uint) startState;
			int kind = 0x7fffffff;
			for(;;)
			{
				if (++jjround == 0x7fffffff)
					ReInitRounds();
				char character = input_stream.CurrentCharacter;
				if (character < 64)
				{
					long l = 1L << character;
					do
					{
						switch(jjstateSet[--i])
						{
							case 23:
								if (character == 36)
									jjCheckNAddTwoStates(20, 21);
								if (character == 36)
								{
									if (kind > 10)
										kind = 10;
								}
								break;
							case 7:
								if (character == 36)
									jjCheckNAddTwoStates(20, 21);
								else if (character == 35)
									jjstateSet[jjnewStateCnt++] = 9;
								if (character == 36)
								{
									if (kind > 10)
										kind = 10;
								}
								break;
							case 14:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 12;
								break;
							case 11:
								if ((0xffffffe7ffffffffUL & (ulong) l) != 0L)
								{
									if (kind > 18)
										kind = 18;
									jjCheckNAdd(5);
								}
								else if (character == 36)
								{
									if (kind > 10)
										kind = 10;
									jjCheckNAddTwoStates(20, 21);
								}
								else if (character == 35)
									jjCheckNAddTwoStates(3, 14);
								if ((0x100000200L & l) != 0L)
									jjCheckNAddTwoStates(0, 4);
								break;
							case 0:
								if ((0x100000200L & l) != 0L)
									jjCheckNAddTwoStates(0, 4);
								break;
							case 4:
								if (character == 35)
									jjCheckNAdd(3);
								break;
							case 5:
								if ((0xffffffe7ffffffffUL & (ulong) l) == 0L)
									break;
								if (kind > 18)
									kind = 18;
								jjCheckNAdd(5);
								break;
							case 8:
								if (character == 35)
									jjstateSet[jjnewStateCnt++] = 9;
								break;
							case 10:
								if ((0x3ff000000000000L & l) == 0L)
									break;
								if (kind > 8)
									kind = 8;
								jjstateSet[jjnewStateCnt++] = 10;
								break;
							case 12:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 13;
								break;
							case 13:
								if ((0xfffffff7ffffffffUL & (ulong) l) != 0L && kind > 13)
									kind = 13;
								break;
							case 17:
								if (character == 36 && kind > 10)
									kind = 10;
								break;
							case 19:
								if (character == 36)
									jjCheckNAddTwoStates(20, 21);
								break;
							case 21:
								if (character == 33 && kind > 11)
									kind = 11;
								break;
							case 22:
								if (character != 36)
									break;
								if (kind > 10)
									kind = 10;
								jjCheckNAddTwoStates(20, 21);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else if (character < 128)
				{
					long l = 1L << (character & 63);
					do
					{
						switch(jjstateSet[--i])
						{
							case 23:
								if (character == 92)
									jjAddStates(48, 49);
								if (character == 92)
									jjCheckNAddTwoStates(18, 19);
								if (character == 92)
									jjCheckNAddTwoStates(16, 17);
								break;
							case 7:
								if (character == 92)
									jjCheckNAddTwoStates(18, 19);
								if (character == 92)
									jjCheckNAddTwoStates(16, 17);
								if (character == 92)
									jjstateSet[jjnewStateCnt++] = 6;
								break;
							case 14:
							case 3:
								if (character == 115)
									jjstateSet[jjnewStateCnt++] = 2;
								break;
							case 11:
								if ((0xffffffffefffffffUL & (ulong) l) != 0L)
								{
									if (kind > 18)
										kind = 18;
									jjCheckNAdd(5);
								}
								else if (character == 92)
									jjCheckNAddStates(50, 53);
								if (character == 92)
									jjAddStates(48, 49);
								break;
							case 1:
								if (character == 116 && kind > 9)
									kind = 9;
								break;
							case 2:
								if (character == 101)
									jjstateSet[jjnewStateCnt++] = 1;
								break;
							case 5:
								if ((0xffffffffefffffffUL & (ulong) l) == 0L)
									break;
								if (kind > 18)
									kind = 18;
								jjCheckNAdd(5);
								break;
							case 6:
								if (character == 92)
									jjAddStates(48, 49);
								break;
							case 9:
							case 10:
								if ((0x7fffffe87fffffeL & l) == 0L)
									break;
								if (kind > 8)
									kind = 8;
								jjCheckNAdd(10);
								break;
							case 13:
								if (kind > 13)
									kind = 13;
								break;
							case 15:
								if (character == 92)
									jjCheckNAddStates(50, 53);
								break;
							case 16:
								if (character == 92)
									jjCheckNAddTwoStates(16, 17);
								break;
							case 18:
								if (character == 92)
									jjCheckNAddTwoStates(18, 19);
								break;
							case 20:
								if (character == 92)
									jjAddStates(54, 55);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else
				{
					int hiByte = (character >> 8);
					int i1 = hiByte >> 6;
					long l1 = 1L << (hiByte & 63);
					int i2 = (character & 0xff) >> 6;
					long l2 = 1L << (character & 63);
					do
					{
						switch(jjstateSet[--i])
						{
							case 11:
							case 5:
								if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
									break;
								if (kind > 18)
									kind = 18;
								jjCheckNAdd(5);
								break;
							case 13:
								if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
									kind = 13;
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				if (kind != 0x7fffffff)
				{
					jjmatchedKind = kind;
					jjmatchedPos = curPos;
					kind = 0x7fffffff;
				}
				++curPos;
				if ((i = jjnewStateCnt) == (startsAt = 23 - (jjnewStateCnt = startsAt)))
					return curPos;

				if (!input_stream.ReadChar())
				{
					return curPos;
					// TODO:  added because this is what will happen when you read past the end of the buffer
					//} catch (IndexOutOfRangeException ex) {
					//    return curPos;
				}
			}
		}

		private int jjStopStringLiteralDfa_7(int pos, long active0)
		{
			switch(pos)
			{
				case 0:
					if ((active0 & 0xd000L) != 0L)
						return 2;
					return -1;
				default:
					return -1;
			}
		}

		private int jjStartNfa_7(int pos, long active0)
		{
			return jjMoveNfa_7(jjStopStringLiteralDfa_7(pos, active0), pos + 1);
		}

		private int jjStartNfaWithStates_7(int pos, int kind, int state)
		{
			jjmatchedKind = kind;
			jjmatchedPos = pos;
			if (!input_stream.ReadChar())
			{
				return pos + 1;
			}
			return jjMoveNfa_7(state, pos + 1);
		}

		private int jjMoveStringLiteralDfa0_7()
		{
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					jjmatchedKind = 15;
					return jjMoveStringLiteralDfa1_7(0x5000L);
				case (char) 42:
					return jjMoveStringLiteralDfa1_7(0x100000L);
				default:
					return jjMoveNfa_7(3, 0);
			}
		}

		private int jjMoveStringLiteralDfa1_7(long active0)
		{
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_7(0, active0);
				return 1;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					if ((active0 & 0x1000L) != 0L)
						return jjStopAtPos(1, 12);
					else if ((active0 & 0x100000L) != 0L)
						return jjStopAtPos(1, 20);
					break;
				case (char) 42:
					if ((active0 & 0x4000L) != 0L)
						return jjStartNfaWithStates_7(1, 14, 0);
					break;
				default:
					break;
			}
			return jjStartNfa_7(0, active0);
		}

		private int jjMoveNfa_7(int startState, int curPos)
		{
			int startsAt = 0;
			jjnewStateCnt = 12;
			int i = 1;
			jjstateSet[0] = (uint) startState;
			int kind = 0x7fffffff;
			for(;;)
			{
				if (++jjround == 0x7fffffff)
					ReInitRounds();
				char character = input_stream.CurrentCharacter;
				if (character < 64)
				{
					long l = 1L << character;
					do
					{
						switch(jjstateSet[--i])
						{
							case 3:
								if (character == 36)
								{
									if (kind > 10)
										kind = 10;
									jjCheckNAddTwoStates(9, 10);
								}
								else if (character == 35)
									jjstateSet[jjnewStateCnt++] = 2;
								break;
							case 0:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 1;
								break;
							case 1:
								if ((0xfffffff7ffffffffUL & (ulong) l) != 0L && kind > 13)
									kind = 13;
								break;
							case 2:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 0;
								break;
							case 6:
								if (character == 36 && kind > 10)
									kind = 10;
								break;
							case 8:
								if (character == 36)
									jjCheckNAddTwoStates(9, 10);
								break;
							case 10:
								if (character == 33 && kind > 11)
									kind = 11;
								break;
							case 11:
								if (character != 36)
									break;
								if (kind > 10)
									kind = 10;
								jjCheckNAddTwoStates(9, 10);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else if (character < 128)
				{
					do
					{
						switch(jjstateSet[--i])
						{
							case 3:
								if (character == 92)
									jjCheckNAddStates(28, 31);
								break;
							case 1:
								if (kind > 13)
									kind = 13;
								break;
							case 5:
								if (character == 92)
									jjCheckNAddTwoStates(5, 6);
								break;
							case 7:
								if (character == 92)
									jjCheckNAddTwoStates(7, 8);
								break;
							case 9:
								if (character == 92)
									jjAddStates(32, 33);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else
				{
					int hiByte = (character >> 8);
					int i1 = hiByte >> 6;
					long l1 = 1L << (hiByte & 63);
					int i2 = (character & 0xff) >> 6;
					long l2 = 1L << (character & 63);
					do
					{
						switch(jjstateSet[--i])
						{
							case 1:
								if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
									kind = 13;
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				if (kind != 0x7fffffff)
				{
					jjmatchedKind = kind;
					jjmatchedPos = curPos;
					kind = 0x7fffffff;
				}
				++curPos;
				if ((i = jjnewStateCnt) == (startsAt = 12 - (jjnewStateCnt = startsAt)))
					return curPos;
				if (!input_stream.ReadChar())
				{
					return curPos;
				}
			}
		}

		private int jjStopStringLiteralDfa_8(int pos, long active0)
		{
			switch(pos)
			{
				case 0:
					if ((active0 & 0xd000L) != 0L)
						return 2;
					return -1;
				default:
					return -1;
			}
		}

		private int jjStartNfa_8(int pos, long active0)
		{
			return jjMoveNfa_8(jjStopStringLiteralDfa_8(pos, active0), pos + 1);
		}

		private int jjStartNfaWithStates_8(int pos, int kind, int state)
		{
			jjmatchedKind = kind;
			jjmatchedPos = pos;
			if (!input_stream.ReadChar())
			{
				return pos + 1;
			}
			return jjMoveNfa_8(state, pos + 1);
		}

		private int jjMoveStringLiteralDfa0_8()
		{
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					jjmatchedKind = 15;
					return jjMoveStringLiteralDfa1_8(0x5000L);
				default:
					return jjMoveNfa_8(3, 0);
			}
		}

		private int jjMoveStringLiteralDfa1_8(long active0)
		{
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_8(0, active0);
				return 1;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					if ((active0 & 0x1000L) != 0L)
						return jjStopAtPos(1, 12);
					break;
				case (char) 42:
					if ((active0 & 0x4000L) != 0L)
						return jjStartNfaWithStates_8(1, 14, 0);
					break;
				default:
					break;
			}
			return jjStartNfa_8(0, active0);
		}

		private int jjMoveNfa_8(int startState, int curPos)
		{
			int startsAt = 0;
			jjnewStateCnt = 15;
			int i = 1;
			jjstateSet[0] = (uint) startState;
			int kind = 0x7fffffff;
			for(;;)
			{
				if (++jjround == 0x7fffffff)
					ReInitRounds();
				char character = input_stream.CurrentCharacter;
				if (character < 64)
				{
					long l = 1L << character;
					do
					{
						switch(jjstateSet[--i])
						{
							case 3:
								if ((0x2400L & l) != 0L)
								{
									if (kind > 19)
										kind = 19;
								}
								else if (character == 36)
								{
									if (kind > 10)
										kind = 10;
									jjCheckNAddTwoStates(12, 13);
								}
								else if (character == 35)
									jjstateSet[jjnewStateCnt++] = 2;
								if (character == 13)
									jjstateSet[jjnewStateCnt++] = 5;
								break;
							case 0:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 1;
								break;
							case 1:
								if ((0xfffffff7ffffffffUL & (ulong) l) != 0L && kind > 13)
									kind = 13;
								break;
							case 2:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 0;
								break;
							case 4:
								if ((0x2400L & l) != 0L && kind > 19)
									kind = 19;
								break;
							case 5:
								if (character == 10 && kind > 19)
									kind = 19;
								break;
							case 6:
								if (character == 13)
									jjstateSet[jjnewStateCnt++] = 5;
								break;
							case 9:
								if (character == 36 && kind > 10)
									kind = 10;
								break;
							case 11:
								if (character == 36)
									jjCheckNAddTwoStates(12, 13);
								break;
							case 13:
								if (character == 33 && kind > 11)
									kind = 11;
								break;
							case 14:
								if (character != 36)
									break;
								if (kind > 10)
									kind = 10;
								jjCheckNAddTwoStates(12, 13);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else if (character < 128)
				{
					do
					{
						switch(jjstateSet[--i])
						{
							case 3:
								if (character == 92)
									jjCheckNAddStates(56, 59);
								break;
							case 1:
								if (kind > 13)
									kind = 13;
								break;
							case 8:
								if (character == 92)
									jjCheckNAddTwoStates(8, 9);
								break;
							case 10:
								if (character == 92)
									jjCheckNAddTwoStates(10, 11);
								break;
							case 12:
								if (character == 92)
									jjAddStates(60, 61);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else
				{
					int hiByte = (character >> 8);
					int i1 = hiByte >> 6;
					long l1 = 1L << (hiByte & 63);
					int i2 = (character & 0xff) >> 6;
					long l2 = 1L << (character & 63);
					do
					{
						switch(jjstateSet[--i])
						{
							case 1:
								if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
									kind = 13;
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				if (kind != 0x7fffffff)
				{
					jjmatchedKind = kind;
					jjmatchedPos = curPos;
					kind = 0x7fffffff;
				}
				++curPos;
				if ((i = jjnewStateCnt) == (startsAt = 15 - (jjnewStateCnt = startsAt)))
					return curPos;
				if (!input_stream.ReadChar())
				{
					return curPos;
				}
			}
		}

		private int jjStopStringLiteralDfa_5(int pos, long active0)
		{
			switch(pos)
			{
				case 0:
					if ((active0 & 0xd000L) != 0L)
						return 2;
					if ((active0 & 0x6000000L) != 0L)
					{
						jjmatchedKind = 56;
						return 5;
					}
					return -1;
				case 1:
					if ((active0 & 0x4000L) != 0L)
						return 0;
					if ((active0 & 0x6000000L) != 0L)
					{
						jjmatchedKind = 56;
						jjmatchedPos = 1;
						return 5;
					}
					return -1;
				case 2:
					if ((active0 & 0x6000000L) != 0L)
					{
						jjmatchedKind = 56;
						jjmatchedPos = 2;
						return 5;
					}
					return -1;
				case 3:
					if ((active0 & 0x4000000L) != 0L)
					{
						jjmatchedKind = 56;
						jjmatchedPos = 3;
						return 5;
					}
					if ((active0 & 0x2000000L) != 0L)
						return 5;
					return -1;
				default:
					return -1;
			}
		}

		private int jjStartNfa_5(int pos, long active0)
		{
			return jjMoveNfa_5(jjStopStringLiteralDfa_5(pos, active0), pos + 1);
		}

		private int jjStartNfaWithStates_5(int pos, int kind, int state)
		{
			jjmatchedKind = kind;
			jjmatchedPos = pos;
			if (!input_stream.ReadChar())
			{
				return pos + 1;
			}
			return jjMoveNfa_5(state, pos + 1);
		}

		private int jjMoveStringLiteralDfa0_5()
		{
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					jjmatchedKind = 15;
					return jjMoveStringLiteralDfa1_5(0x5000L);
				case (char) 102:
					return jjMoveStringLiteralDfa1_5(0x4000000L);
				case (char) 116:
					return jjMoveStringLiteralDfa1_5(0x2000000L);
				case (char) 123:
					return jjStopAtPos(0, 58);
				case (char) 125:
					return jjStopAtPos(0, 59);
				default:
					return jjMoveNfa_5(3, 0);
			}
		}

		private int jjMoveStringLiteralDfa1_5(long active0)
		{
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_5(0, active0);
				return 1;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					if ((active0 & 0x1000L) != 0L)
						return jjStopAtPos(1, 12);
					break;
				case (char) 42:
					if ((active0 & 0x4000L) != 0L)
						return jjStartNfaWithStates_5(1, 14, 0);
					break;
				case (char) 97:
					return jjMoveStringLiteralDfa2_5(active0, 0x4000000L);
				case (char) 114:
					return jjMoveStringLiteralDfa2_5(active0, 0x2000000L);
				default:
					break;
			}
			return jjStartNfa_5(0, active0);
		}

		private int jjMoveStringLiteralDfa2_5(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_5(0, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_5(1, active0);
				return 2;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 108:
					return jjMoveStringLiteralDfa3_5(active0, 0x4000000L);
				case (char) 117:
					return jjMoveStringLiteralDfa3_5(active0, 0x2000000L);
				default:
					break;
			}
			return jjStartNfa_5(1, active0);
		}

		private int jjMoveStringLiteralDfa3_5(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_5(1, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_5(2, active0);
				return 3;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 101:
					if ((active0 & 0x2000000L) != 0L)
						return jjStartNfaWithStates_5(3, 25, 5);
					break;
				case (char) 115:
					return jjMoveStringLiteralDfa4_5(active0, 0x4000000L);
				default:
					break;
			}
			return jjStartNfa_5(2, active0);
		}

		private int jjMoveStringLiteralDfa4_5(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_5(2, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_5(3, active0);
				return 4;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 101:
					if ((active0 & 0x4000000L) != 0L)
						return jjStartNfaWithStates_5(4, 26, 5);
					break;
				default:
					break;
			}
			return jjStartNfa_5(3, active0);
		}

		private int jjMoveNfa_5(int startState, int curPos)
		{
			int startsAt = 0;
			jjnewStateCnt = 16;
			int i = 1;
			jjstateSet[0] = (uint) startState;
			int kind = 0x7fffffff;
			for(;;)
			{
				if (++jjround == 0x7fffffff)
					ReInitRounds();
				char character = input_stream.CurrentCharacter;
				if (character < 64)
				{
					long l = 1L << character;
					do
					{
						switch(jjstateSet[--i])
						{
							case 3:
								if (character == 36)
								{
									if (kind > 10)
										kind = 10;
									jjCheckNAddTwoStates(13, 14);
								}
								else if (character == 46)
									jjstateSet[jjnewStateCnt++] = 7;
								else if (character == 35)
									jjstateSet[jjnewStateCnt++] = 2;
								break;
							case 0:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 1;
								break;
							case 1:
								if ((0xfffffff7ffffffffUL & (ulong) l) != 0L && kind > 13)
									kind = 13;
								break;
							case 2:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 0;
								break;
							case 5:
								if ((0x3ff200000000000L & l) == 0L)
									break;
								if (kind > 56)
									kind = 56;
								jjstateSet[jjnewStateCnt++] = 5;
								break;
							case 6:
								if (character == 46)
									jjstateSet[jjnewStateCnt++] = 7;
								break;
							case 10:
								if (character == 36 && kind > 10)
									kind = 10;
								break;
							case 12:
								if (character == 36)
									jjCheckNAddTwoStates(13, 14);
								break;
							case 14:
								if (character == 33 && kind > 11)
									kind = 11;
								break;
							case 15:
								if (character != 36)
									break;
								if (kind > 10)
									kind = 10;
								jjCheckNAddTwoStates(13, 14);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else if (character < 128)
				{
					long l = 1L << (character & 63);
					do
					{
						switch(jjstateSet[--i])
						{
							case 3:
								if ((0x7fffffe87fffffeL & l) != 0L)
								{
									if (kind > 56)
										kind = 56;
									jjCheckNAdd(5);
								}
								else if (character == 92)
									jjCheckNAddStates(40, 43);
								break;
							case 1:
								if (kind > 13)
									kind = 13;
								break;
							case 4:
							case 5:
								if ((0x7fffffe87fffffeL & l) == 0L)
									break;
								if (kind > 56)
									kind = 56;
								jjCheckNAdd(5);
								break;
							case 7:
								if ((0x7fffffe07fffffeL & l) != 0L && kind > 57)
									kind = 57;
								break;
							case 8:
								if (character == 92)
									jjCheckNAddStates(40, 43);
								break;
							case 9:
								if (character == 92)
									jjCheckNAddTwoStates(9, 10);
								break;
							case 11:
								if (character == 92)
									jjCheckNAddTwoStates(11, 12);
								break;
							case 13:
								if (character == 92)
									jjAddStates(46, 47);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else
				{
					int hiByte = (character >> 8);
					int i1 = hiByte >> 6;
					long l1 = 1L << (hiByte & 63);
					int i2 = (character & 0xff) >> 6;
					long l2 = 1L << (character & 63);
					do
					{
						switch(jjstateSet[--i])
						{
							case 1:
								if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
									kind = 13;
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				if (kind != 0x7fffffff)
				{
					jjmatchedKind = kind;
					jjmatchedPos = curPos;
					kind = 0x7fffffff;
				}
				++curPos;
				if ((i = jjnewStateCnt) == (startsAt = 16 - (jjnewStateCnt = startsAt)))
					return curPos;
				if (!input_stream.ReadChar())
				{
					return curPos;
				}
			}
		}

		private int jjStopStringLiteralDfa_1(int pos, long active0)
		{
			switch(pos)
			{
				case 0:
					if ((active0 & 0xd000L) != 0L)
						return 2;
					if ((active0 & 0x6000000L) != 0L)
					{
						jjmatchedKind = 56;
						return 25;
					}
					if ((active0 & 0x10L) != 0L)
						return 27;
					return -1;
				case 1:
					if ((active0 & 0x4000L) != 0L)
						return 0;
					if ((active0 & 0x6000000L) != 0L)
					{
						jjmatchedKind = 56;
						jjmatchedPos = 1;
						return 25;
					}
					return -1;
				case 2:
					if ((active0 & 0x6000000L) != 0L)
					{
						jjmatchedKind = 56;
						jjmatchedPos = 2;
						return 25;
					}
					return -1;
				case 3:
					if ((active0 & 0x4000000L) != 0L)
					{
						jjmatchedKind = 56;
						jjmatchedPos = 3;
						return 25;
					}
					if ((active0 & 0x2000000L) != 0L)
						return 25;
					return -1;
				default:
					return -1;
			}
		}

		private int jjStartNfa_1(int pos, long active0)
		{
			return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
		}

		private int jjStartNfaWithStates_1(int pos, int kind, int state)
		{
			jjmatchedKind = kind;
			jjmatchedPos = pos;
			if (!input_stream.ReadChar())
			{
				return pos + 1;
			}
			return jjMoveNfa_1(state, pos + 1);
		}

		private int jjMoveStringLiteralDfa0_1()
		{
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					jjmatchedKind = 15;
					return jjMoveStringLiteralDfa1_1(0x5000L);
				case (char) 41:
					return jjStopAtPos(0, 7);
				case (char) 44:
					return jjStopAtPos(0, 3);
				case (char) 46:
					return jjMoveStringLiteralDfa1_1(0x10L);
				case (char) 91:
					return jjStopAtPos(0, 1);
				case (char) 93:
					return jjStopAtPos(0, 2);
				case (char) 102:
					return jjMoveStringLiteralDfa1_1(0x4000000L);
				case (char) 116:
					return jjMoveStringLiteralDfa1_1(0x2000000L);
				case (char) 123:
					return jjStopAtPos(0, 58);
				case (char) 125:
					return jjStopAtPos(0, 59);
				default:
					return jjMoveNfa_1(3, 0);
			}
		}

		private int jjMoveStringLiteralDfa1_1(long active0)
		{
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_1(0, active0);
				return 1;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					if ((active0 & 0x1000L) != 0L)
						return jjStopAtPos(1, 12);
					break;
				case (char) 42:
					if ((active0 & 0x4000L) != 0L)
						return jjStartNfaWithStates_1(1, 14, 0);
					break;
				case (char) 46:
					if ((active0 & 0x10L) != 0L)
						return jjStopAtPos(1, 4);
					break;
				case (char) 97:
					return jjMoveStringLiteralDfa2_1(active0, 0x4000000L);
				case (char) 114:
					return jjMoveStringLiteralDfa2_1(active0, 0x2000000L);
				default:
					break;
			}
			return jjStartNfa_1(0, active0);
		}

		private int jjMoveStringLiteralDfa2_1(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_1(0, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_1(1, active0);
				return 2;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 108:
					return jjMoveStringLiteralDfa3_1(active0, 0x4000000L);
				case (char) 117:
					return jjMoveStringLiteralDfa3_1(active0, 0x2000000L);
				default:
					break;
			}
			return jjStartNfa_1(1, active0);
		}

		private int jjMoveStringLiteralDfa3_1(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_1(1, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_1(2, active0);
				return 3;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 101:
					if ((active0 & 0x2000000L) != 0L)
						return jjStartNfaWithStates_1(3, 25, 25);
					break;
				case (char) 115:
					return jjMoveStringLiteralDfa4_1(active0, 0x4000000L);
				default:
					break;
			}
			return jjStartNfa_1(2, active0);
		}

		private int jjMoveStringLiteralDfa4_1(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_1(2, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_1(3, active0);
				return 4;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 101:
					if ((active0 & 0x4000000L) != 0L)
						return jjStartNfaWithStates_1(4, 26, 25);
					break;
				default:
					break;
			}
			return jjStartNfa_1(3, active0);
		}

		private int jjMoveNfa_1(int startState, int curPos)
		{
			int startsAt = 0;
			jjnewStateCnt = 36;
			int i = 1;
			jjstateSet[0] = (uint) startState;
			int kind = 0x7fffffff;
			for(;;)
			{
				if (++jjround == 0x7fffffff)
					ReInitRounds();
				char character = input_stream.CurrentCharacter;
				if (character < 64)
				{
					long l = 1L << character;
					do
					{
						switch(jjstateSet[--i])
						{
							case 3:
								if ((0x3ff000000000000L & l) != 0L)
								{
									if (kind > 49)
										kind = 49;
									jjCheckNAdd(23);
								}
								else if ((0x100000200L & l) != 0L)
								{
									if (kind > 23)
										kind = 23;
									jjCheckNAdd(4);
								}
								else if (character == 36)
								{
									if (kind > 10)
										kind = 10;
									jjCheckNAddTwoStates(33, 34);
								}
								else if (character == 46)
									jjstateSet[jjnewStateCnt++] = 27;
								else if (character == 45)
									jjCheckNAdd(23);
								else if (character == 39)
									jjCheckNAddStates(62, 64);
								else if (character == 34)
									jjCheckNAddStates(65, 67);
								else if (character == 35)
									jjstateSet[jjnewStateCnt++] = 2;
								break;
							case 0:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 1;
								break;
							case 1:
								if ((0xfffffff7ffffffffUL & (ulong) l) != 0L && kind > 13)
									kind = 13;
								break;
							case 2:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 0;
								break;
							case 4:
								if ((0x100000200L & l) == 0L)
									break;
								if (kind > 23)
									kind = 23;
								jjCheckNAdd(4);
								break;
							case 5:
								if (character == 34)
									jjCheckNAddStates(65, 67);
								break;
							case 6:
								if ((0xfffffffbffffdbffUL & (ulong) l) != 0L)
									jjCheckNAddStates(65, 67);
								break;
							case 7:
								if (character == 34 && kind > 24)
									kind = 24;
								break;
							case 9:
								if ((0x8400000000L & l) != 0L)
									jjCheckNAddStates(65, 67);
								break;
							case 10:
								if ((0xff000000000000L & l) != 0L)
									jjCheckNAddStates(68, 71);
								break;
							case 11:
								if ((0xff000000000000L & l) != 0L)
									jjCheckNAddStates(65, 67);
								break;
							case 12:
								if ((0xf000000000000L & l) != 0L)
									jjstateSet[jjnewStateCnt++] = 13;
								break;
							case 13:
								if ((0xff000000000000L & l) != 0L)
									jjCheckNAdd(11);
								break;
							case 14:
								if (character == 32)
									jjAddStates(72, 73);
								break;
							case 15:
								if (character == 10)
									jjCheckNAddStates(65, 67);
								break;
							case 16:
								if (character == 39)
									jjCheckNAddStates(62, 64);
								break;
							case 17:
								if ((0xffffff7fffffdbffUL & (ulong) l) != 0L)
									jjCheckNAddStates(62, 64);
								break;
							case 19:
								if (character == 32)
									jjAddStates(13, 14);
								break;
							case 20:
								if (character == 10)
									jjCheckNAddStates(62, 64);
								break;
							case 21:
								if (character == 39 && kind > 24)
									kind = 24;
								break;
							case 22:
								if (character == 45)
									jjCheckNAdd(23);
								break;
							case 23:
								if ((0x3ff000000000000L & l) == 0L)
									break;
								if (kind > 49)
									kind = 49;
								jjCheckNAdd(23);
								break;
							case 25:
								if ((0x3ff200000000000L & l) == 0L)
									break;
								if (kind > 56)
									kind = 56;
								jjstateSet[jjnewStateCnt++] = 25;
								break;
							case 26:
								if (character == 46)
									jjstateSet[jjnewStateCnt++] = 27;
								break;
							case 30:
								if (character == 36 && kind > 10)
									kind = 10;
								break;
							case 32:
								if (character == 36)
									jjCheckNAddTwoStates(33, 34);
								break;
							case 34:
								if (character == 33 && kind > 11)
									kind = 11;
								break;
							case 35:
								if (character != 36)
									break;
								if (kind > 10)
									kind = 10;
								jjCheckNAddTwoStates(33, 34);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else if (character < 128)
				{
					long l = 1L << (character & 63);
					do
					{
						switch(jjstateSet[--i])
						{
							case 3:
								if ((0x7fffffe87fffffeL & l) != 0L)
								{
									if (kind > 56)
										kind = 56;
									jjCheckNAdd(25);
								}
								else if (character == 92)
									jjCheckNAddStates(74, 77);
								break;
							case 1:
								if (kind > 13)
									kind = 13;
								break;
							case 6:
								if ((0xffffffffefffffffUL & (ulong) l) != 0L)
									jjCheckNAddStates(65, 67);
								break;
							case 8:
								if (character == 92)
									jjAddStates(78, 82);
								break;
							case 9:
								if ((0x14404410000000L & l) != 0L)
									jjCheckNAddStates(65, 67);
								break;
							case 17:
								jjAddStates(62, 64);
								break;
							case 18:
								if (character == 92)
									jjAddStates(13, 14);
								break;
							case 24:
							case 25:
								if ((0x7fffffe87fffffeL & l) == 0L)
									break;
								if (kind > 56)
									kind = 56;
								jjCheckNAdd(25);
								break;
							case 27:
								if ((0x7fffffe07fffffeL & l) != 0L && kind > 57)
									kind = 57;
								break;
							case 28:
								if (character == 92)
									jjCheckNAddStates(74, 77);
								break;
							case 29:
								if (character == 92)
									jjCheckNAddTwoStates(29, 30);
								break;
							case 31:
								if (character == 92)
									jjCheckNAddTwoStates(31, 32);
								break;
							case 33:
								if (character == 92)
									jjAddStates(83, 84);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else
				{
					int hiByte = (character >> 8);
					int i1 = hiByte >> 6;
					long l1 = 1L << (hiByte & 63);
					int i2 = (character & 0xff) >> 6;
					long l2 = 1L << (character & 63);
					do
					{
						switch(jjstateSet[--i])
						{
							case 1:
								if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
									kind = 13;
								break;
							case 6:
								if (jjCanMove_0(hiByte, i1, i2, l1, l2))
									jjAddStates(65, 67);
								break;
							case 17:
								if (jjCanMove_0(hiByte, i1, i2, l1, l2))
									jjAddStates(62, 64);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				if (kind != 0x7fffffff)
				{
					jjmatchedKind = kind;
					jjmatchedPos = curPos;
					kind = 0x7fffffff;
				}
				++curPos;
				if ((i = jjnewStateCnt) == (startsAt = 36 - (jjnewStateCnt = startsAt)))
					return curPos;
				if (!input_stream.ReadChar())
				{
					return curPos;
				}
			}
		}

		private int jjStopStringLiteralDfa_2(int pos, long active0)
		{
			switch(pos)
			{
				case 0:
					if ((active0 & 0xd000L) != 0L)
						return 2;
					if ((active0 & 0x6000000L) != 0L)
					{
						jjmatchedKind = 56;
						return 5;
					}
					return -1;
				case 1:
					if ((active0 & 0x4000L) != 0L)
						return 0;
					if ((active0 & 0x6000000L) != 0L)
					{
						jjmatchedKind = 56;
						jjmatchedPos = 1;
						return 5;
					}
					return -1;
				case 2:
					if ((active0 & 0x6000000L) != 0L)
					{
						jjmatchedKind = 56;
						jjmatchedPos = 2;
						return 5;
					}
					return -1;
				case 3:
					if ((active0 & 0x4000000L) != 0L)
					{
						jjmatchedKind = 56;
						jjmatchedPos = 3;
						return 5;
					}
					if ((active0 & 0x2000000L) != 0L)
						return 5;
					return -1;
				default:
					return -1;
			}
		}

		private int jjStartNfa_2(int pos, long active0)
		{
			return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
		}

		private int jjStartNfaWithStates_2(int pos, int kind, int state)
		{
			jjmatchedKind = kind;
			jjmatchedPos = pos;
			if (!input_stream.ReadChar())
			{
				return pos + 1;
			}
			return jjMoveNfa_2(state, pos + 1);
		}

		private int jjMoveStringLiteralDfa0_2()
		{
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					jjmatchedKind = 15;
					return jjMoveStringLiteralDfa1_2(0x5000L);
				case (char) 40:
					return jjStopAtPos(0, 5);
				case (char) 102:
					return jjMoveStringLiteralDfa1_2(0x4000000L);
				case (char) 116:
					return jjMoveStringLiteralDfa1_2(0x2000000L);
				case (char) 123:
					return jjStopAtPos(0, 58);
				case (char) 125:
					return jjStopAtPos(0, 59);
				default:
					return jjMoveNfa_2(3, 0);
			}
		}

		private int jjMoveStringLiteralDfa1_2(long active0)
		{
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_2(0, active0);
				return 1;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 35:
					if ((active0 & 0x1000L) != 0L)
						return jjStopAtPos(1, 12);
					break;
				case (char) 42:
					if ((active0 & 0x4000L) != 0L)
						return jjStartNfaWithStates_2(1, 14, 0);
					break;
				case (char) 97:
					return jjMoveStringLiteralDfa2_2(active0, 0x4000000L);
				case (char) 114:
					return jjMoveStringLiteralDfa2_2(active0, 0x2000000L);
				default:
					break;
			}
			return jjStartNfa_2(0, active0);
		}

		private int jjMoveStringLiteralDfa2_2(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_2(0, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_2(1, active0);
				return 2;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 108:
					return jjMoveStringLiteralDfa3_2(active0, 0x4000000L);
				case (char) 117:
					return jjMoveStringLiteralDfa3_2(active0, 0x2000000L);
				default:
					break;
			}
			return jjStartNfa_2(1, active0);
		}

		private int jjMoveStringLiteralDfa3_2(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_2(1, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_2(2, active0);
				return 3;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 101:
					if ((active0 & 0x2000000L) != 0L)
						return jjStartNfaWithStates_2(3, 25, 5);
					break;
				case (char) 115:
					return jjMoveStringLiteralDfa4_2(active0, 0x4000000L);
				default:
					break;
			}
			return jjStartNfa_2(2, active0);
		}

		private int jjMoveStringLiteralDfa4_2(long old0, long active0)
		{
			if (((active0 &= old0)) == 0L)
				return jjStartNfa_2(2, old0);
			if (!input_stream.ReadChar())
			{
				jjStopStringLiteralDfa_2(3, active0);
				return 4;
			}
			switch(input_stream.CurrentCharacter)
			{
				case (char) 101:
					if ((active0 & 0x4000000L) != 0L)
						return jjStartNfaWithStates_2(4, 26, 5);
					break;
				default:
					break;
			}
			return jjStartNfa_2(3, active0);
		}

		private int jjMoveNfa_2(int startState, int curPos)
		{
			int startsAt = 0;
			jjnewStateCnt = 16;
			int i = 1;
			jjstateSet[0] = (uint) startState;
			int kind = 0x7fffffff;
			for(;;)
			{
				if (++jjround == 0x7fffffff)
					ReInitRounds();
				char character = input_stream.CurrentCharacter;
				if (character < 64)
				{
					long l = 1L << character;
					do
					{
						switch(jjstateSet[--i])
						{
							case 3:
								if (character == 36)
								{
									if (kind > 10)
										kind = 10;
									jjCheckNAddTwoStates(13, 14);
								}
								else if (character == 46)
									jjstateSet[jjnewStateCnt++] = 7;
								else if (character == 35)
									jjstateSet[jjnewStateCnt++] = 2;
								break;
							case 0:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 1;
								break;
							case 1:
								if ((0xfffffff7ffffffffUL & (ulong) l) != 0L && kind > 13)
									kind = 13;
								break;
							case 2:
								if (character == 42)
									jjstateSet[jjnewStateCnt++] = 0;
								break;
							case 5:
								if ((0x3ff200000000000L & l) == 0L)
									break;
								if (kind > 56)
									kind = 56;
								jjstateSet[jjnewStateCnt++] = 5;
								break;
							case 6:
								if (character == 46)
									jjstateSet[jjnewStateCnt++] = 7;
								break;
							case 10:
								if (character == 36 && kind > 10)
									kind = 10;
								break;
							case 12:
								if (character == 36)
									jjCheckNAddTwoStates(13, 14);
								break;
							case 14:
								if (character == 33 && kind > 11)
									kind = 11;
								break;
							case 15:
								if (character != 36)
									break;
								if (kind > 10)
									kind = 10;
								jjCheckNAddTwoStates(13, 14);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else if (character < 128)
				{
					long l = 1L << (character & 63);
					do
					{
						switch(jjstateSet[--i])
						{
							case 3:
								if ((0x7fffffe87fffffeL & l) != 0L)
								{
									if (kind > 56)
										kind = 56;
									jjCheckNAdd(5);
								}
								else if (character == 92)
									jjCheckNAddStates(40, 43);
								break;
							case 1:
								if (kind > 13)
									kind = 13;
								break;
							case 4:
							case 5:
								if ((0x7fffffe87fffffeL & l) == 0L)
									break;
								if (kind > 56)
									kind = 56;
								jjCheckNAdd(5);
								break;
							case 7:
								if ((0x7fffffe07fffffeL & l) != 0L && kind > 57)
									kind = 57;
								break;
							case 8:
								if (character == 92)
									jjCheckNAddStates(40, 43);
								break;
							case 9:
								if (character == 92)
									jjCheckNAddTwoStates(9, 10);
								break;
							case 11:
								if (character == 92)
									jjCheckNAddTwoStates(11, 12);
								break;
							case 13:
								if (character == 92)
									jjAddStates(46, 47);
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				else
				{
					int hiByte = character >> 8;
					int i1 = hiByte >> 6;
					long l1 = 1L << (hiByte & 63);
					int i2 = (character & 0xff) >> 6;
					long l2 = 1L << (character & 63);
					do
					{
						switch(jjstateSet[--i])
						{
							case 1:
								if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 13)
									kind = 13;
								break;
							default:
								break;
						}
					} while(i != startsAt);
				}
				if (kind != 0x7fffffff)
				{
					jjmatchedKind = kind;
					jjmatchedPos = curPos;
					kind = 0x7fffffff;
				}
				++curPos;
				if ((i = jjnewStateCnt) == (startsAt = 16 - (jjnewStateCnt = startsAt)))
					return curPos;
				if (!input_stream.ReadChar())
				{
					return curPos;
				}
			}
		}

		private static int[] jjnextStates = {
		                                    	22, 23, 26, 11, 12, 13, 1, 2, 4, 11, 16, 12, 13, 19, 20, 24,
		                                    	25, 35, 36, 37, 38, 14, 15, 17, 19, 20, 39, 40, 5, 6, 7, 8,
		                                    	9, 10, 24, 25, 27, 18, 19, 21, 9, 10, 11, 12, 22, 29, 13, 14,
		                                    	7, 8, 16, 17, 18, 19, 20, 21, 8, 9, 10, 11, 12, 13, 17, 18,
		                                    	21, 6, 7, 8, 6, 11, 7, 8, 14, 15, 29, 30, 31, 32, 9, 10,
		                                    	12, 14, 15, 33, 34,
		                                    };

		private static bool jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
		{
			switch(hiByte)
			{
				case 0:
					return ((jjbitVec2[i2] & (ulong) l2) != 0L);
				default:
					if ((jjbitVec0[i1] & (ulong) l1) != 0L)
						return true;
					return false;
			}
		}

		public static String[] jjstrLiteralImages = {
		                                            	null, null, null, null, null, null, null, null, null, null, null, null,
		                                            	null,
		                                            	null, null, null, null, null, null, null, null, null, null, null, null,
		                                            	null, null,
		                                            	null, null, null, null, null, null, null, null, null, null, null, null,
		                                            	null, null,
		                                            	null, null, null, null, null, null, null, null, null, null, null, null,
		                                            	null, null,
		                                            	null, null, null, null, null, null, null,
		                                            };

		public static String[] lexStateNames = {
		                                       	"DIRECTIVE",
		                                       	"REFMOD2",
		                                       	"REFMODIFIER",
		                                       	"DEFAULT",
		                                       	"PRE_DIRECTIVE",
		                                       	"REFERENCE",
		                                       	"IN_MULTI_LINE_COMMENT",
		                                       	"IN_FORMAL_COMMENT",
		                                       	"IN_SINGLE_LINE_COMMENT",
		                                       };

		public static int[] jjnewLexState = {
		                                    	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		                                    	-1, -1, -1, -1, -1,
		                                    	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		                                    	-1, -1, -1, -1, -1,
		                                    	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		                                    };

		private static long[] jjtoToken = {
		                                  	0xf12ffffffbf03ffL,
		                                  };

		private static long[] jjtoSkip = {
		                                 	0x3000000000000000L,
		                                 };

		private static long[] jjtoSpecial = {
		                                    	0x3000000000000000L,
		                                    };

		private ICharStream input_stream;
		private uint[] jjrounds = new uint[42];
		private uint[] jjstateSet = new uint[84];
		private StringBuilder image;
		private int jjimageLen;

		public ParserTokenManager(ICharStream stream)
		{
			input_stream = stream;
		}

		public ParserTokenManager(ICharStream stream, int lexState) : this(stream)
		{
			SwitchTo(lexState);
		}

		public void ReInit(ICharStream stream)
		{
			jjmatchedPos = jjnewStateCnt = 0;
			curLexState = defaultLexState;
			input_stream = stream;
			ReInitRounds();
		}

		private void ReInitRounds()
		{
			int i;
			jjround = 0x80000001;
			for(i = 42; i-- > 0;)
				jjrounds[i] = 0x80000000;
		}

		public void ReInit(ICharStream stream, int lexState)
		{
			ReInit(stream);
			SwitchTo(lexState);
		}

		public void SwitchTo(int lexState)
		{
			if (lexState >= 9 || lexState < 0)
				throw new TokenMgrError(string.Format("Error: Ignoring invalid lexical state : {0}. State unchanged.", lexState),
				                        TokenMgrError.INVALID_LEXICAL_STATE);
			else
				curLexState = lexState;
		}

		private Token jjFillToken()
		{
			Token t = Token.NewToken(jjmatchedKind);
			t.Kind = jjmatchedKind;
			String im = jjstrLiteralImages[jjmatchedKind];
			t.Image = (im == null) ? input_stream.GetImage() : im;
			t.BeginLine = input_stream.BeginLine;
			t.BeginColumn = input_stream.BeginColumn;
			t.EndLine = input_stream.EndLine;
			t.EndColumn = input_stream.EndColumn;
			return t;
		}

		private int curLexState = 3;
		private int defaultLexState = 3;
		private int jjnewStateCnt;
		private uint jjround;
		private int jjmatchedPos;
		private int jjmatchedKind;

		public Token NextToken
		{
			get
			{
				Token specialToken = null;
				Token matchedToken;
				int curPos = 0;

				for(;;)
				{
					if (!input_stream.BeginToken())
					{
						jjmatchedKind = 0;
						matchedToken = jjFillToken();
						matchedToken.SpecialToken = specialToken;
						return matchedToken;
					}
					image = null;
					jjimageLen = 0;

					for(;;)
					{
						switch(curLexState)
						{
							case 0:
								jjmatchedKind = 0x7fffffff;
								jjmatchedPos = 0;
								curPos = jjMoveStringLiteralDfa0_0();
								break;
							case 1:
								jjmatchedKind = 0x7fffffff;
								jjmatchedPos = 0;
								curPos = jjMoveStringLiteralDfa0_1();
								if (jjmatchedPos == 0 && jjmatchedKind > 60)
								{
									jjmatchedKind = 60;
								}
								break;
							case 2:
								jjmatchedKind = 0x7fffffff;
								jjmatchedPos = 0;
								curPos = jjMoveStringLiteralDfa0_2();
								if (jjmatchedPos == 0 && jjmatchedKind > 60)
								{
									jjmatchedKind = 60;
								}
								break;
							case 3:
								jjmatchedKind = 0x7fffffff;
								jjmatchedPos = 0;
								curPos = jjMoveStringLiteralDfa0_3();
								break;
							case 4:
								jjmatchedKind = 0x7fffffff;
								jjmatchedPos = 0;
								curPos = jjMoveStringLiteralDfa0_4();
								if (jjmatchedPos == 0 && jjmatchedKind > 61)
								{
									jjmatchedKind = 61;
								}
								break;
							case 5:
								jjmatchedKind = 0x7fffffff;
								jjmatchedPos = 0;
								curPos = jjMoveStringLiteralDfa0_5();
								if (jjmatchedPos == 0 && jjmatchedKind > 60)
								{
									jjmatchedKind = 60;
								}
								break;
							case 6:
								jjmatchedKind = 0x7fffffff;
								jjmatchedPos = 0;
								curPos = jjMoveStringLiteralDfa0_6();
								if (jjmatchedPos == 0 && jjmatchedKind > 22)
								{
									jjmatchedKind = 22;
								}
								break;
							case 7:
								jjmatchedKind = 0x7fffffff;
								jjmatchedPos = 0;
								curPos = jjMoveStringLiteralDfa0_7();
								if (jjmatchedPos == 0 && jjmatchedKind > 22)
								{
									jjmatchedKind = 22;
								}
								break;
							case 8:
								jjmatchedKind = 0x7fffffff;
								jjmatchedPos = 0;
								curPos = jjMoveStringLiteralDfa0_8();
								if (jjmatchedPos == 0 && jjmatchedKind > 22)
								{
									jjmatchedKind = 22;
								}
								break;
						}
						if (jjmatchedKind != 0x7fffffff)
						{
							if (jjmatchedPos + 1 < curPos)
								input_stream.Backup(curPos - jjmatchedPos - 1);
							if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 63))) != 0L)
							{
								matchedToken = jjFillToken();
								matchedToken.SpecialToken = specialToken;
								TokenLexicalActions(matchedToken);
								if (jjnewLexState[jjmatchedKind] != -1)
									curLexState = jjnewLexState[jjmatchedKind];
								return matchedToken;
							}
							else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 63))) != 0L)
							{
								if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 63))) != 0L)
								{
									matchedToken = jjFillToken();
									if (specialToken == null)
										specialToken = matchedToken;
									else
									{
										matchedToken.SpecialToken = specialToken;
										specialToken = (specialToken.Next = matchedToken);
									}
									SkipLexicalActions();
								}
								else
									SkipLexicalActions();
								if (jjnewLexState[jjmatchedKind] != -1)
									curLexState = jjnewLexState[jjmatchedKind];
								goto EOFLoop_GOTO;
							}
							MoreLexicalActions();
							if (jjnewLexState[jjmatchedKind] != -1)
								curLexState = jjnewLexState[jjmatchedKind];
							curPos = 0;
							jjmatchedKind = 0x7fffffff;

							if (input_stream.ReadChar())
							{
								continue;
							}
						}
						int error_line = input_stream.EndLine;
						int error_column = input_stream.EndColumn;
						String error_after = null;
						bool EOFSeen = false;
						if (input_stream.ReadChar())
						{
							input_stream.Backup(1);
						}
						else
						{
							EOFSeen = true;
							error_after = curPos <= 1 ? string.Empty : input_stream.GetImage();
							char character = input_stream.CurrentCharacter;
							if (character == '\n' || character == '\r')
							{
								error_line++;
								error_column = 0;
							}
							else
								error_column++;
						}
						if (!EOFSeen)
						{
							input_stream.Backup(1);
							error_after = curPos <= 1 ? string.Empty : input_stream.GetImage();
						}
						throw new TokenMgrError(EOFSeen, error_line, error_column, error_after, input_stream.CurrentCharacter,
						                        TokenMgrError.LEXICAL_ERROR);
					}
					EOFLoop_GOTO :
					;
				}
			}
		}

		private void SkipLexicalActions()
		{
			switch(jjmatchedKind)
			{
				case 60:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					/*
		    * push every terminator character back into the stream  
		    */

					input_stream.Backup(1);

					if (debugPrint)
						Console.Out.Write("REF_TERM :");

					StateStackPop();
					break;
				case 61:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					if (debugPrint)
						Console.Out.Write("DIRECTIVE_TERM :");

					input_stream.Backup(1);
					inDirective = false;
					StateStackPop();
					break;
				default:
					break;
			}
		}

		private void MoreLexicalActions()
		{
			jjimageLen += (jjmatchedPos + 1);
			switch(jjmatchedKind)
			{
				case 10:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen)));
					else
						image.Append(input_stream.GetSuffix(jjimageLen));
					jjimageLen = 0;
					if (! inComment)
					{
						/*
			* if we find ourselves in REFERENCE, we need to pop down
			* to end the previous ref
			*/

						if (curLexState == REFERENCE)
						{
							StateStackPop();
						}

						if (debugPrint)
							Console.Out.Write("$  : going to {0}", REFERENCE);

						StateStackPush();
						SwitchTo(REFERENCE);
					}
					break;
				case 11:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen)));
					else
						image.Append(input_stream.GetSuffix(jjimageLen));
					jjimageLen = 0;
					if (! inComment)
					{
						/*
			* if we find ourselves in REFERENCE, we need to pop down
			* to end the previous ref
			*/

						if (curLexState == REFERENCE)
						{
							StateStackPop();
						}

						if (debugPrint)
							Console.Out.Write("$!  : going to {0}", REFERENCE);

						StateStackPush();
						SwitchTo(REFERENCE);
					}
					break;
				case 12:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen)));
					else
						image.Append(input_stream.GetSuffix(jjimageLen));
					jjimageLen = 0;
					if (!inComment)
					{
						if (curLexState == REFERENCE)
						{
							StateStackPop();
						}

						inComment = true;
						StateStackPush();
						SwitchTo(IN_SINGLE_LINE_COMMENT);
					}
					break;
				case 13:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen)));
					else
						image.Append(input_stream.GetSuffix(jjimageLen));
					jjimageLen = 0;
					input_stream.Backup(1);
					inComment = true;
					StateStackPush();
					SwitchTo(IN_FORMAL_COMMENT);
					break;
				case 14:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen)));
					else
						image.Append(input_stream.GetSuffix(jjimageLen));
					jjimageLen = 0;
					inComment = true;
					StateStackPush();
					SwitchTo(IN_MULTI_LINE_COMMENT);
					break;
				case 15:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen)));
					else
						image.Append(input_stream.GetSuffix(jjimageLen));
					jjimageLen = 0;
					if (! inComment)
					{
						/*
			* We can have the situation where #if($foo)$foo#end.  
			* We need to transition out of REFERENCE before going to DIRECTIVE. 
			* I don't really like this, but I can't think of a legal way 
			* you are going into DIRECTIVE while in REFERENCE.  -gmj
			*/

						if (curLexState == REFERENCE || curLexState == REFMODIFIER)
						{
							StateStackPop();
						}

						inDirective = true;

						if (debugPrint)
							Console.Out.Write("# :  going to {0}", DIRECTIVE);

						StateStackPush();
						SwitchTo(PRE_DIRECTIVE);
					}
					break;
				default:
					break;
			}
		}

		private void TokenLexicalActions(Token matchedToken)
		{
			switch(jjmatchedKind)
			{
				case 5:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					if (!inComment)
						lparen++;

					/*
		    * If in REFERENCE and we have seen the dot, then move 
		    * to REFMOD2 -> Modifier()
		    */

					if (curLexState == REFMODIFIER)
						SwitchTo(REFMOD2);
					break;
				case 6:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					RPARENHandler();
					break;
				case 7:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					/*
		    * need to simply switch back to REFERENCE, not drop down the stack
		    * because we can (infinitely) chain, ala 
		    * $foo.bar().blargh().woogie().doogie()
		    */

					SwitchTo(REFERENCE);
					break;
				case 9:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					if (! inComment)
					{
						inDirective = true;

						if (debugPrint)
							Console.Out.Write("#set :  going to {0}", DIRECTIVE);

						StateStackPush();
						inSet = true;
						SwitchTo(DIRECTIVE);
					}
					break;
				case 19:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					inComment = false;
					StateStackPop();
					break;
				case 20:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					inComment = false;
					StateStackPop();
					break;
				case 21:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					inComment = false;
					StateStackPop();
					break;
				case 24:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					/*
		    *  - if we are in DIRECTIVE and haven't seen ( yet, then also drop out. 
		    *      don't forget to account for the beloved yet wierd #set
		    *  - finally, if we are in REFMOD2 (remember : $foo.bar( ) then " is ok!
		    */

					if (curLexState == DIRECTIVE && !inSet && lparen == 0)
						StateStackPop();
					break;
				case 27:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					if (debugPrint)
						Console.Out.WriteLine(" NEWLINE :");

					StateStackPop();

					if (inSet)
						inSet = false;

					if (inDirective)
						inDirective = false;
					break;
				case 43:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					inDirective = false;
					StateStackPop();
					break;
				case 44:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					SwitchTo(DIRECTIVE);
					break;
				case 45:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					SwitchTo(DIRECTIVE);
					break;
				case 46:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					inDirective = false;
					StateStackPop();
					break;
				case 47:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					matchedToken.Kind = EOF;
					break;
				case 49:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					/*
		    * check to see if we are in set
		    *    ex.  #set $foo = $foo + 3
		    *  because we want to handle the \n after
		    */

					if (lparen == 0 && !inSet && curLexState != REFMOD2)
					{
						StateStackPop();
					}
					break;
				case 57:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					/*
		    * push the alpha char back into the stream so the following identifier 
		    * is complete
		    */

					input_stream.Backup(1);

					/*
		    * and munge the <DOT> so we just get a . when we have normal text that 
		    * looks like a ref.ident
		    */

					matchedToken.Image = ".";

					if (debugPrint)
						Console.Out.Write("DOT : switching to {0}", REFMODIFIER);
					SwitchTo(REFMODIFIER);
					break;
				case 59:
					if (image == null)
						image = new StringBuilder(new String(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1))));
					else
						image.Append(input_stream.GetSuffix(jjimageLen + (jjmatchedPos + 1)));
					StateStackPop();
					break;
				default:
					break;
			}
		}
	}
}