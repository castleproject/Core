using System;
using System.IO;
using NVelocity.Runtime.Parser.Node;
using NVelocity.Runtime.Directive;
using Macro = NVelocity.Runtime.Directive.Macro;
using StringUtils = NVelocity.Util.StringUtils;
using NVelocity.Runtime;

/* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */
namespace NVelocity.Runtime.Parser {

    /// <summary> This class is responsible for parsing a Velocity
    /// template. This class was generated by JavaCC using
    /// the JJTree extension to produce an Abstract
    /// Syntax Tree (AST) of the template.
    ///
    /// Please look at the Parser.jjt file which is
    /// what controls the generation of this class.
    /// </summary>
    public class Parser {
	private void  InitBlock() {
	    jjtree = new JJTParserState();
	    directives = new System.Collections.Hashtable(0);
	    jj_la1 = new int[53];
	    jj_2_rtns = new JJCalls[12];
	    jj_expentries = new System.Collections.ArrayList();
	    jj_lasttokens = new int[100];
	}
	public virtual System.Collections.Hashtable Directives {
	    set {
		this.directives = value;
	    }

	}
	public virtual Token NextToken {
	    get {
		if (token.next != null)
		    token = token.next;
		else
		    token = token.next = token_source.NextToken;
		jj_ntk_Renamed_Field = - 1;
		jj_gen++;
		return token;
	    }

	}
	/*@bgen(jjtree)*/
	//UPGRADE_NOTE: The initialization of  'jjtree' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
	internal JJTParserState jjtree;
	/// <summary>  This Hashtable contains a list of all of the dynamic directives.
	/// </summary>
	//UPGRADE_NOTE: The initialization of  'directives' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
	private System.Collections.Hashtable directives;

	/// <summary>  Name of current template we are parsing.  Passed to us in parse()
	/// </summary>
	internal System.String currentTemplateName = "";

	internal VelocityCharStream velcharstream = null;

	private RuntimeServices rsvc = null;

	///
	/// <summary> This constructor was added to allow the re-use of parsers.
	/// The normal constructor takes a single argument which
	/// an InputStream. This simply creates a re-usable parser
	/// object, we satisfy the requirement of an InputStream
	/// by using a newline character as an input stream.
	/// </summary>
	public Parser(RuntimeServices rs):this(new VelocityCharStream(new StringReader("\n"), 1, 1)) {
	    InitBlock();

	    /*
	    * now setup a VCS for later use
	    */
	    velcharstream = new VelocityCharStream(new StringReader("\n"), 1, 1);

	    /*
	    *  and save the RuntimeServices
	    */
	    rsvc = rs;
	}

	///
	/// <summary> This was also added to allow parsers to be
	/// re-usable. Normal JavaCC use entails passing an
	/// input stream to the constructor and the parsing
	/// process is carried out once. We want to be able
	/// to re-use parsers: we do this by adding this
	/// method and re-initializing the lexer with
	/// the new stream that we want parsed.
	/// </summary>
	public virtual SimpleNode parse(System.IO.TextReader reader, System.String templateName) {
	    SimpleNode sn = null;

	    currentTemplateName = templateName;

	    try {
		token_source.clearStateVars();

		/*
				*  reinitialize the VelocityCharStream
				*  with the new reader
				*/
		velcharstream.ReInit(reader, 1, 1);

		/*
				* now reinit the Parser with this CharStream
				*/
		ReInit(velcharstream);

		/*
				*  do that voodoo...
				*/
		sn = process();
	    } catch (ParseException pe) {
		rsvc.error("Parser Exception: " + templateName + " : " + StringUtils.stackTrace(pe));
		throw new ParseException(pe.currentToken, pe.expectedTokenSequences, pe.tokenImage);
	    } catch (TokenMgrError tme) {
		throw new ParseException("Lexical error: " + tme.ToString());
	    } catch (System.Exception e) {
		rsvc.error("Parser Error: " + templateName + " : " + StringUtils.stackTrace(e));
	    }

	    currentTemplateName = "";

	    return sn;
	}

	/// <summary>  This method sets the directives Hashtable
	/// </summary>

	/// <summary>  This method gets a Directive from the directives Hashtable
	/// </summary>
	public virtual Directive.Directive getDirective(System.String directive) {
	    return (Directive.Directive) directives[directive];
	}

	/// <summary>  This method finds out of the directive exists in the directives
	/// Hashtable.
	/// </summary>
	public virtual bool isDirective(System.String directive) {
	    if (directives.ContainsKey(directive))
		return true;
	    else
		return false;
	}


	/// <summary> Produces a processed output for an escaped control or
	/// pluggable directive
	/// </summary>
	private System.String escapedDirective(System.String strImage) {
	    int iLast = strImage.LastIndexOf("\\");

	    System.String strDirective = strImage.Substring(iLast + 1);

	    bool bRecognizedDirective = false;

	    /*
	    *  is this a PD or a control directive?
	    */

	    if (isDirective(strDirective.Substring(1))) {
		bRecognizedDirective = true;
	    } else if (rsvc.isVelocimacro(strDirective.Substring(1), currentTemplateName)) {
		bRecognizedDirective = true;
	    } else {
		/* order for speed? */

		if (strDirective.Substring(1).Equals("if") || strDirective.Substring(1).Equals("end") || strDirective.Substring(1).Equals("set") || strDirective.Substring(1).Equals("else") || strDirective.Substring(1).Equals("elseif") || strDirective.Substring(1).Equals("stop")) {
		    bRecognizedDirective = true;
		}
	    }

	    /*
	    *  if so, make the proper prefix string (let the escapes do their thing..)
	    *  otherwise, just return what it is..
	    */

	    if (bRecognizedDirective)
		return (strImage.Substring(0, (iLast / 2) - (0)) + strDirective);
	    else
		return (strImage);
	}

	/// <summary> This method is what starts the whole parsing
	/// process. After the parsing is complete and
	/// the template has been turned into an AST,
	/// this method returns the root of AST which
	/// can subsequently be traversed by a visitor
	/// which implements the ParserVisitor interface
	/// which is generated automatically by JavaCC
	/// </summary>
	public SimpleNode process() {
	    /*@bgen(jjtree) process */
	    ASTprocess jjtn000 = new ASTprocess(this, ParserTreeConstants.JJTPROCESS);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    //UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
	    try {
		while (true) {
		    switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
			case ParserConstants.LPAREN:
			case ParserConstants.RPAREN:
			case ParserConstants.ESCAPE_DIRECTIVE:
			case ParserConstants.SET_DIRECTIVE:
			case ParserConstants.DOUBLE_ESCAPE:
			case ParserConstants.ESCAPE:
			case ParserConstants.TEXT:
			case ParserConstants.SINGLE_LINE_COMMENT:
			case ParserConstants.FORMAL_COMMENT:
			case ParserConstants.MULTI_LINE_COMMENT:
			case ParserConstants.STRING_LITERAL:
			case ParserConstants.IF_DIRECTIVE:
			case ParserConstants.STOP_DIRECTIVE:
			case ParserConstants.NUMBER_LITERAL:
			case ParserConstants.WORD:
			case ParserConstants.IDENTIFIER:
			case ParserConstants.DOT:
			case ParserConstants.LCURLY:
			case ParserConstants.RCURLY:
			    ;
			    break;

			default:
			    jj_la1[0] = jj_gen;
			    //UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
			    goto label_1_brk;

		    }
		    Statement();
		}
		//UPGRADE_NOTE: Label 'label_1_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_1_brk:
		;

		jj_consume_token(0);
		jjtree.closeNodeScope(jjtn000, true);
		jjtc000 = false;
		if (true)
		    return jjtn000;

	    } catch (System.Exception jjte000) {
		if (jjtc000) {
		    jjtree.clearNodeScope(jjtn000);
		    jjtc000 = false;
		} else {
		    jjtree.popNode();
		}
		if (jjte000 is System.SystemException) {
		    if (true)
			throw (System.SystemException) jjte000;

		}
		if (jjte000 is ParseException) {
		    if (true)
			throw (ParseException) jjte000;

		}
		if (true)
		    throw (System.ApplicationException) jjte000;

	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	    throw new System.ApplicationException("Missing return statement in function");
	}

	/// <summary> These are the types of statements that
	/// are acceptable in Velocity templates.
	/// </summary>
	public void  Statement() {
	    switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		case ParserConstants.IF_DIRECTIVE:
		    IfStatement();
		    break;

		case ParserConstants.STOP_DIRECTIVE:
		    StopStatement();
		    break;

		default:
		    jj_la1[1] = jj_gen;
		    if (jj_2_1(2)) {
			Reference();
		    } else {
			switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.SINGLE_LINE_COMMENT: case ParserConstants.FORMAL_COMMENT: case ParserConstants.MULTI_LINE_COMMENT:
				Comment();
				break;

			    case ParserConstants.SET_DIRECTIVE:
				SetDirective();
				break;

			    case ParserConstants.ESCAPE_DIRECTIVE:
				EscapedDirective();
				break;

			    case ParserConstants.DOUBLE_ESCAPE:
				Escape();
				break;

			    case ParserConstants.WORD:
				Directive();
				break;

			    case ParserConstants.LPAREN:
			    case ParserConstants.RPAREN:
			    case ParserConstants.ESCAPE:
			    case ParserConstants.TEXT:
			    case ParserConstants.STRING_LITERAL:
			    case ParserConstants.NUMBER_LITERAL:
			    case ParserConstants.DOT:
			    case ParserConstants.LCURLY:
			    case ParserConstants.RCURLY:
				Text();
				break;

			    default:
				jj_la1[2] = jj_gen;
				jj_consume_token(- 1);
				throw new ParseException();

			}
		    }
		    break;

	    }
	}

	/// <summary>  used to separate the notion of a valid directive that has been
	/// escaped, versus something that looks like a directive and
	/// is just schmoo.  This is important to do as a separate production
	/// that creates a node, because we want this, in either case, to stop
	/// the further parsing of the Directive() tree.
	/// </summary>
	public void  EscapedDirective() {
	    /*@bgen(jjtree) EscapedDirective */
	    ASTEscapedDirective jjtn000 = new ASTEscapedDirective(this, ParserTreeConstants.JJTESCAPEDDIRECTIVE);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    try {
		Token t = null;
		t = jj_consume_token(ParserConstants.ESCAPE_DIRECTIVE);
		jjtree.closeNodeScope(jjtn000, true);
		jjtc000 = false;
		/*
				*  churn and burn..
				*/
		t.image = escapedDirective(t.image);
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	/// <summary>  Used to catch and process escape sequences in grammatical constructs
	/// as escapes outside of VTL are just characters.  Right now we have both
	/// this and the EscapeDirective() construction because in the EscapeDirective()
	/// case, we want to suck in the #<directive> and here we don't.  We just want
	/// the escapes to render correctly
	/// </summary>
	public void  Escape() {
	    /*@bgen(jjtree) Escape */
	    ASTEscape jjtn000 = new ASTEscape(this, ParserTreeConstants.JJTESCAPE);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    try {
		Token t = null;
		int count = 0;
		bool control = false;
		while (true) {
		    t = jj_consume_token(ParserConstants.DOUBLE_ESCAPE);
		    count++;
		    if (jj_2_2(2)) {
			;
		    } else {
			//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
			goto label_2_brk;
		    }
		}
		//UPGRADE_NOTE: Label 'label_2_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_2_brk:
		;

		jjtree.closeNodeScope(jjtn000, true);
		jjtc000 = false;
		/*
				* first, check to see if we have a control directive
				*/
		switch (t.next.kind) {
		    case ParserConstants.IF_DIRECTIVE:
		    case ParserConstants.ELSE_DIRECTIVE:
		    case ParserConstants.ELSEIF_DIRECTIVE:
		    case ParserConstants.END:
		    case ParserConstants.STOP_DIRECTIVE:
			control = true;
			break;

		}

		/*
				* if that failed, lets lookahead to see if we matched a PD or a VM
				*/

		if (isDirective(t.next.image.Substring(1)))
		    control = true;
		else if (rsvc.isVelocimacro(t.next.image.Substring(1), currentTemplateName))
		    control = true;

		t.image = "";

		for (int i = 0; i < count; i++)
		    t.image += (control?"\\":"\\\\");
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	public void  Comment() {
	    /*@bgen(jjtree) Comment */
	    ASTComment jjtn000 = new ASTComment(this, ParserTreeConstants.JJTCOMMENT);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    try {
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.SINGLE_LINE_COMMENT:
			jj_consume_token(ParserConstants.SINGLE_LINE_COMMENT);
			break;

		    case ParserConstants.MULTI_LINE_COMMENT:
			jj_consume_token(ParserConstants.MULTI_LINE_COMMENT);
			break;

		    case ParserConstants.FORMAL_COMMENT:
			jj_consume_token(ParserConstants.FORMAL_COMMENT);
			break;

		    default:
			jj_la1[3] = jj_gen;
			jj_consume_token(- 1);
			throw new ParseException();

		}
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	public void  NumberLiteral() {
	    /*@bgen(jjtree) NumberLiteral */
	    ASTNumberLiteral jjtn000 = new ASTNumberLiteral(this, ParserTreeConstants.JJTNUMBERLITERAL);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    try {
		jj_consume_token(ParserConstants.NUMBER_LITERAL);
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	public void  StringLiteral() {
	    /*@bgen(jjtree) StringLiteral */
	    ASTStringLiteral jjtn000 = new ASTStringLiteral(this, ParserTreeConstants.JJTSTRINGLITERAL);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    try {
		jj_consume_token(ParserConstants.STRING_LITERAL);
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	/// <summary> This method corresponds to variable
	/// references in Velocity templates.
	/// The following are examples of variable
	/// references that may be found in a
	/// template:
	/// *
	/// $foo
	/// $bar
	/// *
	/// </summary>
	public void  Identifier() {
	    /*@bgen(jjtree) Identifier */
	    ASTIdentifier jjtn000 = new ASTIdentifier(this, ParserTreeConstants.JJTIDENTIFIER);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    try {
		jj_consume_token(ParserConstants.IDENTIFIER);
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	public void  Word() {
	    /*@bgen(jjtree) Word */
	    ASTWord jjtn000 = new ASTWord(this, ParserTreeConstants.JJTWORD);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    try {
		jj_consume_token(ParserConstants.WORD);
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	/// <summary>   Supports the arguments for the Pluggable Directives
	/// We add whitespace in here as a token so the VMs can
	/// easily reconstruct a macro body from the token stream
	/// See Directive()
	/// </summary>
	public void  DirectiveArg() {
	    switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
	    case ParserConstants.IDENTIFIER: case ParserConstants.LCURLY:
		    Reference();
		    break;

		case ParserConstants.WORD:
		    Word();
		    break;

		case ParserConstants.STRING_LITERAL:
		    StringLiteral();
		    break;

		case ParserConstants.NUMBER_LITERAL:
		    NumberLiteral();
		    break;

		default:
		    jj_la1[4] = jj_gen;
		    if (jj_2_3(2147483647)) {
			IntegerRange();
		    } else {
			switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
			    case ParserConstants.LBRACKET:
				ObjectArray();
				break;

			    case ParserConstants.TRUE:
				True();
				break;

			    case ParserConstants.FALSE:
				False();
				break;

			    case ParserConstants.WHITESPACE:
				jj_consume_token(ParserConstants.WHITESPACE);
				break;

			    default:
				jj_la1[5] = jj_gen;
				jj_consume_token(- 1);
				throw new ParseException();

			}
		    }
		    break;

	    }
	}

	/// <summary>   Supports the Pluggable Directives
	/// #foo( arg+ )
	/// </summary>
	public SimpleNode Directive() {
	    /*@bgen(jjtree) Directive */
	    ASTDirective jjtn000 = new ASTDirective(this, ParserTreeConstants.JJTDIRECTIVE);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    Token t = null;
	    Directive.Directive d;
	    int directiveType;
	    bool doItNow = false;
	    //UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
	    try {
		/*
		* note that if we were escaped, that is now handled by 
		* EscapedDirective()
		*/
		t = jj_consume_token(ParserConstants.WORD);
		System.String directiveName = t.image.Substring(1);

		d = (Directive.Directive) directives[directiveName];

		/*
		*  Velocimacro support : if the directive is macro directive
		*   then set the flag so after the block parsing, we add the VM
		*   right then. (So available if used w/in the current template )
		*/

		if (directiveName.Equals("macro")) {
		    doItNow = true;
		}

		/*
		* set the directive name from here.  No reason for the thing to know 
		* about parser tokens
		*/

		jjtn000.DirectiveName = directiveName;

		if (d == null) {
		    /*
		    *  if null, then not a real directive, but maybe a Velocimacro
		    */

		    //d  =  (Directive) rsvc.getVelocimacro( directiveName, currentTemplateName );

		    // TODO: adding a null check since RuntimeServices is not finished
		    // since the parser can be created without RuntimeServices - this may actually be needed here and in the orgiginal source as well.
		    if (rsvc != null) {
			if (!rsvc.isVelocimacro(directiveName, currentTemplateName)) {
			    token_source.stateStackPop();
			    token_source.inDirective = false;
			    if (true)
				return jjtn000;
			}
		    }

		    /*
		    *  Currently, all VMs are LINE directives
		    */
		    directiveType = NVelocity.Runtime.Directive.DirectiveConstants_Fields.LINE;
		} else {
		    directiveType = d.Type;
		}

		/*
				*  now, switch us out of PRE_DIRECTIVE
				*/

		token_source.SwitchTo(ParserConstants.DIRECTIVE);
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.WHITESPACE:
			jj_consume_token(ParserConstants.WHITESPACE);
			break;

		    default:
			jj_la1[6] = jj_gen;
			;
			break;

		}
		jj_consume_token(ParserConstants.LPAREN);
		while (true) {
		    switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
case ParserConstants.LBRACKET: case ParserConstants.WHITESPACE: case ParserConstants.STRING_LITERAL: case ParserConstants.TRUE: case ParserConstants.FALSE: case ParserConstants.NUMBER_LITERAL: case ParserConstants.WORD: case ParserConstants.IDENTIFIER: case ParserConstants.LCURLY:
			    ;
			    break;

			default:
			    jj_la1[7] = jj_gen;
			    //UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
			    goto label_3_brk;

		    }
		    DirectiveArg();
		}
		//UPGRADE_NOTE: Label 'label_3_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_3_brk:
		;

		jj_consume_token(ParserConstants.RPAREN);
		if (directiveType == NVelocity.Runtime.Directive.DirectiveConstants_Fields.LINE) {
		    if (true)
			return jjtn000;
		}
		ASTBlock jjtn001 = new ASTBlock(this, ParserTreeConstants.JJTBLOCK);
		bool jjtc001 = true;
		jjtree.openNodeScope(jjtn001);
		//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
		try {
		    while (true) {
			Statement();
			switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
case ParserConstants.LPAREN: case ParserConstants.RPAREN: case ParserConstants.ESCAPE_DIRECTIVE: case ParserConstants.SET_DIRECTIVE: case ParserConstants.DOUBLE_ESCAPE: case ParserConstants.ESCAPE: case ParserConstants.TEXT: case ParserConstants.SINGLE_LINE_COMMENT: case ParserConstants.FORMAL_COMMENT: case ParserConstants.MULTI_LINE_COMMENT: case ParserConstants.STRING_LITERAL: case ParserConstants.IF_DIRECTIVE: case ParserConstants.STOP_DIRECTIVE: case ParserConstants.NUMBER_LITERAL: case ParserConstants.WORD: case ParserConstants.IDENTIFIER: case ParserConstants.DOT: case ParserConstants.LCURLY: case ParserConstants.RCURLY:
				;
				break;

			    default:
				jj_la1[8] = jj_gen;
				//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
				goto label_4_brk;

			}
		    }
		    //UPGRADE_NOTE: Label 'label_4_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_4_brk:
		    ;

		} catch (System.Exception jjte001) {
		    if (jjtc001) {
			jjtree.clearNodeScope(jjtn001);
			jjtc001 = false;
		    } else {
			jjtree.popNode();
		    }
		    if (jjte001 is System.SystemException) { {
			    if (true)
				throw (System.SystemException) jjte001;
			}
		    }
		    if (jjte001 is ParseException) { {
			    if (true)
				throw (ParseException) jjte001;
			}
		    } {
			if (true)
			    throw (System.ApplicationException) jjte001;
		    }
		} finally {
		    if (jjtc001) {
			jjtree.closeNodeScope(jjtn001, true);
		    }
		}
		jj_consume_token(ParserConstants.END);
		jjtree.closeNodeScope(jjtn000, true);
		jjtc000 = false;
		/*
		*  VM : if we are processing a #macro directive, we need to 
		*     process the block.  In truth, I can just register the name
		*     and do the work later when init-ing.  That would work
		*     as long as things were always defined before use.  This way
		*     we don't have to worry about forward references and such...
		*/

		if (doItNow) {
		    Macro.processAndRegister(rsvc, jjtn000, currentTemplateName);
		} {

		    /*
		    *  VM : end
		    */

		    if (true)
			return jjtn000;
		}
	    } catch (System.Exception jjte000) {
		if (jjtc000) {
		    jjtree.clearNodeScope(jjtn000);
		    jjtc000 = false;
		} else {
		    jjtree.popNode();
		}
		if (jjte000 is System.SystemException) { {
			if (true)
			    throw (System.SystemException) jjte000;
		    }
		}
		if (jjte000 is ParseException) { {
			if (true)
			    throw (ParseException) jjte000;
		    }
		} {
		    if (true)
			throw (System.ApplicationException) jjte000;
		}
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	    throw new System.ApplicationException("Missing return statement in function");
	}

	public void  ObjectArray() {
	    /*@bgen(jjtree) ObjectArray */
	    ASTObjectArray jjtn000 = new ASTObjectArray(this, ParserTreeConstants.JJTOBJECTARRAY);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    //UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
	    try {
		jj_consume_token(ParserConstants.LBRACKET);
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
case ParserConstants.LBRACKET: case ParserConstants.WHITESPACE: case ParserConstants.STRING_LITERAL: case ParserConstants.TRUE: case ParserConstants.FALSE: case ParserConstants.NUMBER_LITERAL: case ParserConstants.IDENTIFIER: case ParserConstants.LCURLY:
			Parameter();
			while (true) {
			    switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
				case ParserConstants.COMMA:
				    ;
				    break;

				default:
				    jj_la1[9] = jj_gen;
				    //UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
				    goto label_5_brk;

			    }
			    jj_consume_token(ParserConstants.COMMA);
			    Parameter();
			}
			//UPGRADE_NOTE: Label 'label_5_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_5_brk:
			;

			break;

		    default:
			jj_la1[10] = jj_gen;
			;
			break;

		}
		jj_consume_token(ParserConstants.RBRACKET);
	    } catch (System.Exception jjte000) {
		if (jjtc000) {
		    jjtree.clearNodeScope(jjtn000);
		    jjtc000 = false;
		} else {
		    jjtree.popNode();
		}
		if (jjte000 is System.SystemException) { {
			if (true)
			    throw (System.SystemException) jjte000;
		    }
		}
		if (jjte000 is ParseException) { {
			if (true)
			    throw (ParseException) jjte000;
		    }
		} {
		    if (true)
			throw (System.ApplicationException) jjte000;
		}
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	/// <summary>  supports the [n..m] vector generator for use in
	/// the #foreach() to generate measured ranges w/o
	/// needing explicit support from the app/servlet
	/// </summary>
	public void  IntegerRange() {
	    /*@bgen(jjtree) IntegerRange */
	    ASTIntegerRange jjtn000 = new ASTIntegerRange(this, ParserTreeConstants.JJTINTEGERRANGE);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    //UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
	    try {
		jj_consume_token(ParserConstants.LBRACKET);
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.WHITESPACE:
			jj_consume_token(ParserConstants.WHITESPACE);
			break;

		    default:
			jj_la1[11] = jj_gen;
			;
			break;

		}
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		case ParserConstants.IDENTIFIER: case ParserConstants.LCURLY:
			Reference();
			break;

		    case ParserConstants.NUMBER_LITERAL:
			NumberLiteral();
			break;

		    default:
			jj_la1[12] = jj_gen;
			jj_consume_token(- 1);
			throw new ParseException();

		}
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.WHITESPACE:
			jj_consume_token(ParserConstants.WHITESPACE);
			break;

		    default:
			jj_la1[13] = jj_gen;
			;
			break;

		}
		jj_consume_token(ParserConstants.DOUBLEDOT);
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.WHITESPACE:
			jj_consume_token(ParserConstants.WHITESPACE);
			break;

		    default:
			jj_la1[14] = jj_gen;
			;
			break;

		}
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		case ParserConstants.IDENTIFIER: case ParserConstants.LCURLY:
			Reference();
			break;

		    case ParserConstants.NUMBER_LITERAL:
			NumberLiteral();
			break;

		    default:
			jj_la1[15] = jj_gen;
			jj_consume_token(- 1);
			throw new ParseException();

		}
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.WHITESPACE:
			jj_consume_token(ParserConstants.WHITESPACE);
			break;

		    default:
			jj_la1[16] = jj_gen;
			;
			break;

		}
		jj_consume_token(ParserConstants.RBRACKET);
	    } catch (System.Exception jjte000) {
		if (jjtc000) {
		    jjtree.clearNodeScope(jjtn000);
		    jjtc000 = false;
		} else {
		    jjtree.popNode();
		}
		if (jjte000 is System.SystemException) { {
			if (true)
			    throw (System.SystemException) jjte000;
		    }
		}
		if (jjte000 is ParseException) { {
			if (true)
			    throw (ParseException) jjte000;
		    }
		} {
		    if (true)
			throw (System.ApplicationException) jjte000;
		}
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	/// <summary> This method has yet to be fully implemented
	/// but will allow arbitrarily nested method
	/// calls
	/// </summary>
	public void  Parameter() {
	    switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		case ParserConstants.WHITESPACE:
		    jj_consume_token(ParserConstants.WHITESPACE);
		    break;

		default:
		    jj_la1[17] = jj_gen;
		    ;
		    break;

	    }
	    switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		case ParserConstants.STRING_LITERAL:
		    StringLiteral();
		    break;

		default:
		    jj_la1[18] = jj_gen;
		    if (jj_2_4(2147483647)) {
			IntegerRange();
		    } else {
			switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
			    case ParserConstants.LBRACKET:
				ObjectArray();
				break;

			    case ParserConstants.TRUE:
				True();
				break;

			    case ParserConstants.FALSE:
				False();
				break;

			    case ParserConstants.IDENTIFIER:
			    case ParserConstants.LCURLY:
				Reference();
				break;

			    case ParserConstants.NUMBER_LITERAL:
				NumberLiteral();
				break;

			    default:
				jj_la1[19] = jj_gen;
				jj_consume_token(- 1);
				throw new ParseException();

			}
		    }
		    break;

	    }
	    switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		case ParserConstants.WHITESPACE:
		    jj_consume_token(ParserConstants.WHITESPACE);
		    break;

		default:
		    jj_la1[20] = jj_gen;
		    ;
		    break;

	    }
	}

	/// <summary> This method has yet to be fully implemented
	/// but will allow arbitrarily nested method
	/// calls
	/// </summary>
	public void  Method() {
	    /*@bgen(jjtree) Method */
	    ASTMethod jjtn000 = new ASTMethod(this, ParserTreeConstants.JJTMETHOD);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    //UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
	    try {
		Identifier();
		jj_consume_token(ParserConstants.LPAREN);
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
case ParserConstants.LBRACKET: case ParserConstants.WHITESPACE: case ParserConstants.STRING_LITERAL: case ParserConstants.TRUE: case ParserConstants.FALSE: case ParserConstants.NUMBER_LITERAL: case ParserConstants.IDENTIFIER: case ParserConstants.LCURLY:
			Parameter();
			while (true) {
			    switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
				case ParserConstants.COMMA:
				    ;
				    break;

				default:
				    jj_la1[21] = jj_gen;
				    //UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
				    goto label_6_brk;

			    }
			    jj_consume_token(ParserConstants.COMMA);
			    Parameter();
			}
			//UPGRADE_NOTE: Label 'label_6_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_6_brk:
			;

			break;

		    default:
			jj_la1[22] = jj_gen;
			;
			break;

		}
		jj_consume_token(ParserConstants.REFMOD2_RPAREN);
	    } catch (System.Exception jjte000) {
		if (jjtc000) {
		    jjtree.clearNodeScope(jjtn000);
		    jjtc000 = false;
		} else {
		    jjtree.popNode();
		}
		if (jjte000 is System.SystemException) { {
			if (true)
			    throw (System.SystemException) jjte000;
		    }
		}
		if (jjte000 is ParseException) { {
			if (true)
			    throw (ParseException) jjte000;
		    }
		} {
		    if (true)
			throw (System.ApplicationException) jjte000;
		}
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	public void  Reference() {
	    /*@bgen(jjtree) Reference */
	    ASTReference jjtn000 = new ASTReference(this, ParserTreeConstants.JJTREFERENCE);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    //UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
	    try {
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.IDENTIFIER:
			jj_consume_token(ParserConstants.IDENTIFIER);
			while (true) {
			    if (jj_2_5(2)) {
				;
			    } else {
				//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
				goto label_7_brk;
			    }
			    jj_consume_token(ParserConstants.DOT);
			    if (jj_2_6(3)) {
				Method();
			    } else {
				switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
				    case ParserConstants.IDENTIFIER:
					Identifier();
					break;

				    default:
					jj_la1[23] = jj_gen;
					jj_consume_token(- 1);
					throw new ParseException();

				}
			    }
			}
			//UPGRADE_NOTE: Label 'label_7_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_7_brk:
			;

			break;

		    case ParserConstants.LCURLY:
			jj_consume_token(ParserConstants.LCURLY);
			jj_consume_token(ParserConstants.IDENTIFIER);
			while (true) {
			    if (jj_2_7(2)) {
				;
			    } else {
				//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
				goto label_8_brk;
			    }
			    jj_consume_token(ParserConstants.DOT);
			    if (jj_2_8(3)) {
				Method();
			    } else {
				switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
				    case ParserConstants.IDENTIFIER:
					Identifier();
					break;

				    default:
					jj_la1[24] = jj_gen;
					jj_consume_token(- 1);
					throw new ParseException();

				}
			    }
			}
			//UPGRADE_NOTE: Label 'label_8_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_8_brk:
			;

			jj_consume_token(ParserConstants.RCURLY);
			break;

		    default:
			jj_la1[25] = jj_gen;
			jj_consume_token(- 1);
			throw new ParseException();

		}
	    } catch (System.Exception jjte000) {
		if (jjtc000) {
		    jjtree.clearNodeScope(jjtn000);
		    jjtc000 = false;
		} else {
		    jjtree.popNode();
		}
		if (jjte000 is System.SystemException) { {
			if (true)
			    throw (System.SystemException) jjte000;
		    }
		}
		if (jjte000 is ParseException) { {
			if (true)
			    throw (ParseException) jjte000;
		    }
		} {
		    if (true)
			throw (System.ApplicationException) jjte000;
		}
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	public void  True() {
	    /*@bgen(jjtree) True */
	    ASTTrue jjtn000 = new ASTTrue(this, ParserTreeConstants.JJTTRUE);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    try {
		jj_consume_token(ParserConstants.TRUE);
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	public void  False() {
	    /*@bgen(jjtree) False */
	    ASTFalse jjtn000 = new ASTFalse(this, ParserTreeConstants.JJTFALSE);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    try {
		jj_consume_token(ParserConstants.FALSE);
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	/// <summary> This method is responsible for allowing
	/// all non-grammar text to pass through
	/// unscathed.
	/// </summary>
	public void  Text() {
	    /*@bgen(jjtree) Text */
	    ASTText jjtn000 = new ASTText(this, ParserTreeConstants.JJTTEXT);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    try {
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.TEXT:
			jj_consume_token(ParserConstants.TEXT);
			break;

		    case ParserConstants.DOT:
			jj_consume_token(ParserConstants.DOT);
			break;

		    case ParserConstants.RPAREN:
			jj_consume_token(ParserConstants.RPAREN);
			break;

		    case ParserConstants.LPAREN:
			jj_consume_token(ParserConstants.LPAREN);
			break;

		    case ParserConstants.NUMBER_LITERAL:
			jj_consume_token(ParserConstants.NUMBER_LITERAL);
			break;

		    case ParserConstants.STRING_LITERAL:
			jj_consume_token(ParserConstants.STRING_LITERAL);
			break;

		    case ParserConstants.ESCAPE:
			jj_consume_token(ParserConstants.ESCAPE);
			break;

		    case ParserConstants.LCURLY:
			jj_consume_token(ParserConstants.LCURLY);
			break;

		    case ParserConstants.RCURLY:
			jj_consume_token(ParserConstants.RCURLY);
			break;

		    default:
			jj_la1[26] = jj_gen;
			jj_consume_token(- 1);
			throw new ParseException();

		}
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	/* -----------------------------------------------------------------------
		* 
		*  Defined Directive Syntax
		* 
		* ----------------------------------------------------------------------*/
	public void  IfStatement() {
	    /*@bgen(jjtree) IfStatement */
	    ASTIfStatement jjtn000 = new ASTIfStatement(this, ParserTreeConstants.JJTIFSTATEMENT);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    //UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
	    try {
		jj_consume_token(ParserConstants.IF_DIRECTIVE);
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.WHITESPACE:
			jj_consume_token(ParserConstants.WHITESPACE);
			break;

		    default:
			jj_la1[27] = jj_gen;
			;
			break;

		}
		jj_consume_token(ParserConstants.LPAREN);
		Expression();
		jj_consume_token(ParserConstants.RPAREN);
		ASTBlock jjtn001 = new ASTBlock(this, ParserTreeConstants.JJTBLOCK);
		bool jjtc001 = true;
		jjtree.openNodeScope(jjtn001);
		//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
		try {
		    while (true) {
			Statement();
			switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
case ParserConstants.LPAREN: case ParserConstants.RPAREN: case ParserConstants.ESCAPE_DIRECTIVE: case ParserConstants.SET_DIRECTIVE: case ParserConstants.DOUBLE_ESCAPE: case ParserConstants.ESCAPE: case ParserConstants.TEXT: case ParserConstants.SINGLE_LINE_COMMENT: case ParserConstants.FORMAL_COMMENT: case ParserConstants.MULTI_LINE_COMMENT: case ParserConstants.STRING_LITERAL: case ParserConstants.IF_DIRECTIVE: case ParserConstants.STOP_DIRECTIVE: case ParserConstants.NUMBER_LITERAL: case ParserConstants.WORD: case ParserConstants.IDENTIFIER: case ParserConstants.DOT: case ParserConstants.LCURLY: case ParserConstants.RCURLY:
				;
				break;

			    default:
				jj_la1[28] = jj_gen;
				//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
				goto label_9_brk;

			}
		    }
		    //UPGRADE_NOTE: Label 'label_9_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_9_brk:
		    ;

		} catch (System.Exception jjte001) {
		    if (jjtc001) {
			jjtree.clearNodeScope(jjtn001);
			jjtc001 = false;
		    } else {
			jjtree.popNode();
		    }
		    if (jjte001 is System.SystemException) { {
			    if (true)
				throw (System.SystemException) jjte001;
			}
		    }
		    if (jjte001 is ParseException) { {
			    if (true)
				throw (ParseException) jjte001;
			}
		    } {
			if (true)
			    throw (System.ApplicationException) jjte001;
		    }
		} finally {
		    if (jjtc001) {
			jjtree.closeNodeScope(jjtn001, true);
		    }
		}
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.ELSEIF_DIRECTIVE:
			while (true) {
			    ElseIfStatement();
			    switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
				case ParserConstants.ELSEIF_DIRECTIVE:
				    ;
				    break;

				default:
				    jj_la1[29] = jj_gen;
				    //UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
				    goto label_10_brk;

			    }
			}
			//UPGRADE_NOTE: Label 'label_10_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_10_brk:
			;

			break;

		    default:
			jj_la1[30] = jj_gen;
			;
			break;

		}
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.ELSE_DIRECTIVE:
			ElseStatement();
			break;

		    default:
			jj_la1[31] = jj_gen;
			;
			break;

		}
		jj_consume_token(ParserConstants.END);
	    } catch (System.Exception jjte000) {
		if (jjtc000) {
		    jjtree.clearNodeScope(jjtn000);
		    jjtc000 = false;
		} else {
		    jjtree.popNode();
		}
		if (jjte000 is System.SystemException) { {
			if (true)
			    throw (System.SystemException) jjte000;
		    }
		}
		if (jjte000 is ParseException) { {
			if (true)
			    throw (ParseException) jjte000;
		    }
		} {
		    if (true)
			throw (System.ApplicationException) jjte000;
		}
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	public void  ElseStatement() {
	    /*@bgen(jjtree) ElseStatement */
	    ASTElseStatement jjtn000 = new ASTElseStatement(this, ParserTreeConstants.JJTELSESTATEMENT);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    //UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
	    try {
		jj_consume_token(ParserConstants.ELSE_DIRECTIVE);
		ASTBlock jjtn001 = new ASTBlock(this, ParserTreeConstants.JJTBLOCK);
		bool jjtc001 = true;
		jjtree.openNodeScope(jjtn001);
		//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
		try {
		    while (true) {
			Statement();
			switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
case ParserConstants.LPAREN: case ParserConstants.RPAREN: case ParserConstants.ESCAPE_DIRECTIVE: case ParserConstants.SET_DIRECTIVE: case ParserConstants.DOUBLE_ESCAPE: case ParserConstants.ESCAPE: case ParserConstants.TEXT: case ParserConstants.SINGLE_LINE_COMMENT: case ParserConstants.FORMAL_COMMENT: case ParserConstants.MULTI_LINE_COMMENT: case ParserConstants.STRING_LITERAL: case ParserConstants.IF_DIRECTIVE: case ParserConstants.STOP_DIRECTIVE: case ParserConstants.NUMBER_LITERAL: case ParserConstants.WORD: case ParserConstants.IDENTIFIER: case ParserConstants.DOT: case ParserConstants.LCURLY: case ParserConstants.RCURLY:
				;
				break;

			    default:
				jj_la1[32] = jj_gen;
				//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
				goto label_11_brk;

			}
		    }
		    //UPGRADE_NOTE: Label 'label_11_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_11_brk:
		    ;

		} catch (System.Exception jjte001) {
		    if (jjtc001) {
			jjtree.clearNodeScope(jjtn001);
			jjtc001 = false;
		    } else {
			jjtree.popNode();
		    }
		    if (jjte001 is System.SystemException) { {
			    if (true)
				throw (System.SystemException) jjte001;
			}
		    }
		    if (jjte001 is ParseException) { {
			    if (true)
				throw (ParseException) jjte001;
			}
		    } {
			if (true)
			    throw (System.ApplicationException) jjte001;
		    }
		} finally {
		    if (jjtc001) {
			jjtree.closeNodeScope(jjtn001, true);
		    }
		}
	    } catch (System.Exception jjte000) {
		if (jjtc000) {
		    jjtree.clearNodeScope(jjtn000);
		    jjtc000 = false;
		} else {
		    jjtree.popNode();
		}
		if (jjte000 is System.SystemException) { {
			if (true)
			    throw (System.SystemException) jjte000;
		    }
		}
		if (jjte000 is ParseException) { {
			if (true)
			    throw (ParseException) jjte000;
		    }
		} {
		    if (true)
			throw (System.ApplicationException) jjte000;
		}
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	public void  ElseIfStatement() {
	    /*@bgen(jjtree) ElseIfStatement */
	    ASTElseIfStatement jjtn000 = new ASTElseIfStatement(this, ParserTreeConstants.JJTELSEIFSTATEMENT);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    //UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
	    try {
		jj_consume_token(ParserConstants.ELSEIF_DIRECTIVE);
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.WHITESPACE:
			jj_consume_token(ParserConstants.WHITESPACE);
			break;

		    default:
			jj_la1[33] = jj_gen;
			;
			break;

		}
		jj_consume_token(ParserConstants.LPAREN);
		Expression();
		jj_consume_token(ParserConstants.RPAREN);
		ASTBlock jjtn001 = new ASTBlock(this, ParserTreeConstants.JJTBLOCK);
		bool jjtc001 = true;
		jjtree.openNodeScope(jjtn001);
		//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
		try {
		    while (true) {
			Statement();
			switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
case ParserConstants.LPAREN: case ParserConstants.RPAREN: case ParserConstants.ESCAPE_DIRECTIVE: case ParserConstants.SET_DIRECTIVE: case ParserConstants.DOUBLE_ESCAPE: case ParserConstants.ESCAPE: case ParserConstants.TEXT: case ParserConstants.SINGLE_LINE_COMMENT: case ParserConstants.FORMAL_COMMENT: case ParserConstants.MULTI_LINE_COMMENT: case ParserConstants.STRING_LITERAL: case ParserConstants.IF_DIRECTIVE: case ParserConstants.STOP_DIRECTIVE: case ParserConstants.NUMBER_LITERAL: case ParserConstants.WORD: case ParserConstants.IDENTIFIER: case ParserConstants.DOT: case ParserConstants.LCURLY: case ParserConstants.RCURLY:
				;
				break;

			    default:
				jj_la1[34] = jj_gen;
				//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
				goto label_12_brk;

			}
		    }
		    //UPGRADE_NOTE: Label 'label_12_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_12_brk:
		    ;

		} catch (System.Exception jjte001) {
		    if (jjtc001) {
			jjtree.clearNodeScope(jjtn001);
			jjtc001 = false;
		    } else {
			jjtree.popNode();
		    }
		    if (jjte001 is System.SystemException) { {
			    if (true)
				throw (System.SystemException) jjte001;
			}
		    }
		    if (jjte001 is ParseException) { {
			    if (true)
				throw (ParseException) jjte001;
			}
		    } {
			if (true)
			    throw (System.ApplicationException) jjte001;
		    }
		} finally {
		    if (jjtc001) {
			jjtree.closeNodeScope(jjtn001, true);
		    }
		}
	    } catch (System.Exception jjte000) {
		if (jjtc000) {
		    jjtree.clearNodeScope(jjtn000);
		    jjtc000 = false;
		} else {
		    jjtree.popNode();
		}
		if (jjte000 is System.SystemException) { {
			if (true)
			    throw (System.SystemException) jjte000;
		    }
		}
		if (jjte000 is ParseException) { {
			if (true)
			    throw (ParseException) jjte000;
		    }
		} {
		    if (true)
			throw (System.ApplicationException) jjte000;
		}
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	/// <summary>  Currently support both types of set :
	/// #set( expr )
	/// #set expr
	/// </summary>
	public void  SetDirective() {
	    /*@bgen(jjtree) SetDirective */
	    ASTSetDirective jjtn000 = new ASTSetDirective(this, ParserTreeConstants.JJTSETDIRECTIVE);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    //UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
	    try {
		jj_consume_token(ParserConstants.SET_DIRECTIVE);
		if (jj_2_9(2)) {
		    jj_consume_token(ParserConstants.WHITESPACE);
		} else {
		    ;
		}
		jj_consume_token(ParserConstants.LPAREN);
		Expression();
		jj_consume_token(ParserConstants.RPAREN);
		/*
				* ensure that inSet is false.  Leads to some amusing bugs...
				*/

		token_source.inSet = false;
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.NEWLINE:
			jj_consume_token(ParserConstants.NEWLINE);
			break;

		    default:
			jj_la1[35] = jj_gen;
			;
			break;

		}
	    } catch (System.Exception jjte000) {
		if (jjtc000) {
		    jjtree.clearNodeScope(jjtn000);
		    jjtc000 = false;
		} else {
		    jjtree.popNode();
		}
		if (jjte000 is System.SystemException) { {
			if (true)
			    throw (System.SystemException) jjte000;
		    }
		}
		if (jjte000 is ParseException) { {
			if (true)
			    throw (ParseException) jjte000;
		    }
		} {
		    if (true)
			throw (System.ApplicationException) jjte000;
		}
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	/// <summary> This method corresponds to the #stop
	/// directive which just simulates and EOF
	/// so that parsing stops. The #stop directive
	/// is useful for end-user debugging
	/// purposes.
	/// </summary>
	public void  StopStatement() {
	    jj_consume_token(ParserConstants.STOP_DIRECTIVE);
	}

	/* -----------------------------------------------------------------------
		* 
		*  Expression Syntax
		* 
		* ----------------------------------------------------------------------*/
	public void  Expression() {
	    /*@bgen(jjtree) Expression */
	    ASTExpression jjtn000 = new ASTExpression(this, ParserTreeConstants.JJTEXPRESSION);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    //UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
	    try {
		if (jj_2_10(2147483647)) {
		    Assignment();
		} else {
		    switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
case ParserConstants.LBRACKET: case ParserConstants.LPAREN: case ParserConstants.WHITESPACE: case ParserConstants.STRING_LITERAL: case ParserConstants.TRUE: case ParserConstants.FALSE: case ParserConstants.LOGICAL_NOT: case ParserConstants.NUMBER_LITERAL: case ParserConstants.IDENTIFIER: case ParserConstants.LCURLY:
			    ConditionalOrExpression();
			    break;

			default:
			    jj_la1[36] = jj_gen;
			    jj_consume_token(- 1);
			    throw new ParseException();

		    }
		}
	    } catch (System.Exception jjte000) {
		if (jjtc000) {
		    jjtree.clearNodeScope(jjtn000);
		    jjtc000 = false;
		} else {
		    jjtree.popNode();
		}
		if (jjte000 is System.SystemException) { {
			if (true)
			    throw (System.SystemException) jjte000;
		    }
		}
		if (jjte000 is ParseException) { {
			if (true)
			    throw (ParseException) jjte000;
		    }
		} {
		    if (true)
			throw (System.ApplicationException) jjte000;
		}
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, true);
		}
	    }
	}

	public void  Assignment() {
	    /*@bgen(jjtree) #Assignment( 2) */
	    ASTAssignment jjtn000 = new ASTAssignment(this, ParserTreeConstants.JJTASSIGNMENT);
	    bool jjtc000 = true;
	    jjtree.openNodeScope(jjtn000);
	    //UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
	    try {
		PrimaryExpression();
		jj_consume_token(ParserConstants.EQUALS);
		Expression();
	    } catch (System.Exception jjte000) {
		if (jjtc000) {
		    jjtree.clearNodeScope(jjtn000);
		    jjtc000 = false;
		} else {
		    jjtree.popNode();
		}
		if (jjte000 is System.SystemException) { {
			if (true)
			    throw (System.SystemException) jjte000;
		    }
		}
		if (jjte000 is ParseException) { {
			if (true)
			    throw (ParseException) jjte000;
		    }
		} {
		    if (true)
			throw (System.ApplicationException) jjte000;
		}
	    } finally {
		if (jjtc000) {
		    jjtree.closeNodeScope(jjtn000, 2);
		}
	    }
	}

	public void  ConditionalOrExpression() {
	    ConditionalAndExpression();
	    while (true) {
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.LOGICAL_OR:
			;
			break;

		    default:
			jj_la1[37] = jj_gen;
			//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
			goto label_13_brk;

		}
		jj_consume_token(ParserConstants.LOGICAL_OR);
		ASTOrNode jjtn001 = new ASTOrNode(this, ParserTreeConstants.JJTORNODE);
		bool jjtc001 = true;
		jjtree.openNodeScope(jjtn001);
		//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
		try {
		    ConditionalAndExpression();
		} catch (System.Exception jjte001) {
		    if (jjtc001) {
			jjtree.clearNodeScope(jjtn001);
			jjtc001 = false;
		    } else {
			jjtree.popNode();
		    }
		    if (jjte001 is System.SystemException) { {
			    if (true)
				throw (System.SystemException) jjte001;
			}
		    }
		    if (jjte001 is ParseException) { {
			    if (true)
				throw (ParseException) jjte001;
			}
		    } {
			if (true)
			    throw (System.ApplicationException) jjte001;
		    }
		} finally {
		    if (jjtc001) {
			jjtree.closeNodeScope(jjtn001, 2);
		    }
		}
	    }
	    //UPGRADE_NOTE: Label 'label_13_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_13_brk:
	    ;

	}

	public void  ConditionalAndExpression() {
	    EqualityExpression();
	    while (true) {
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.LOGICAL_AND:
			;
			break;

		    default:
			jj_la1[38] = jj_gen;
			//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
			goto label_14_brk;

		}
		jj_consume_token(ParserConstants.LOGICAL_AND);
		ASTAndNode jjtn001 = new ASTAndNode(this, ParserTreeConstants.JJTANDNODE);
		bool jjtc001 = true;
		jjtree.openNodeScope(jjtn001);
		//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
		try {
		    EqualityExpression();
		} catch (System.Exception jjte001) {
		    if (jjtc001) {
			jjtree.clearNodeScope(jjtn001);
			jjtc001 = false;
		    } else {
			jjtree.popNode();
		    }
		    if (jjte001 is System.SystemException) { {
			    if (true)
				throw (System.SystemException) jjte001;
			}
		    }
		    if (jjte001 is ParseException) { {
			    if (true)
				throw (ParseException) jjte001;
			}
		    } {
			if (true)
			    throw (System.ApplicationException) jjte001;
		    }
		} finally {
		    if (jjtc001) {
			jjtree.closeNodeScope(jjtn001, 2);
		    }
		}
	    }
	    //UPGRADE_NOTE: Label 'label_14_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_14_brk:
	    ;

	}

	public void  EqualityExpression() {
	    RelationalExpression();
	    while (true) {
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		case ParserConstants.LOGICAL_EQUALS: case ParserConstants.LOGICAL_NOT_EQUALS:
			;
			break;

		    default:
			jj_la1[39] = jj_gen;
			//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
			goto label_15_brk;

		}
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.LOGICAL_EQUALS:
			jj_consume_token(ParserConstants.LOGICAL_EQUALS);
			ASTEQNode jjtn001 = new ASTEQNode(this, ParserTreeConstants.JJTEQNODE);
			bool jjtc001 = true;
			jjtree.openNodeScope(jjtn001);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try {
			    RelationalExpression();
			} catch (System.Exception jjte001) {
			    if (jjtc001) {
				jjtree.clearNodeScope(jjtn001);
				jjtc001 = false;
			    } else {
				jjtree.popNode();
			    }
			    if (jjte001 is System.SystemException) { {
				    if (true)
					throw (System.SystemException) jjte001;
				}
			    }
			    if (jjte001 is ParseException) { {
				    if (true)
					throw (ParseException) jjte001;
				}
			    } {
				if (true)
				    throw (System.ApplicationException) jjte001;
			    }
			} finally {
			    if (jjtc001) {
				jjtree.closeNodeScope(jjtn001, 2);
			    }
			}
			break;

		    case ParserConstants.LOGICAL_NOT_EQUALS:
			jj_consume_token(ParserConstants.LOGICAL_NOT_EQUALS);
			ASTNENode jjtn002 = new ASTNENode(this, ParserTreeConstants.JJTNENODE);
			bool jjtc002 = true;
			jjtree.openNodeScope(jjtn002);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try {
			    RelationalExpression();
			} catch (System.Exception jjte002) {
			    if (jjtc002) {
				jjtree.clearNodeScope(jjtn002);
				jjtc002 = false;
			    } else {
				jjtree.popNode();
			    }
			    if (jjte002 is System.SystemException) { {
				    if (true)
					throw (System.SystemException) jjte002;
				}
			    }
			    if (jjte002 is ParseException) { {
				    if (true)
					throw (ParseException) jjte002;
				}
			    } {
				if (true)
				    throw (System.ApplicationException) jjte002;
			    }
			} finally {
			    if (jjtc002) {
				jjtree.closeNodeScope(jjtn002, 2);
			    }
			}
			break;

		    default:
			jj_la1[40] = jj_gen;
			jj_consume_token(- 1);
			throw new ParseException();

		}
	    }
	    //UPGRADE_NOTE: Label 'label_15_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_15_brk:
	    ;

	}

	public void  RelationalExpression() {
	    AdditiveExpression();
	    while (true) {
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
	case ParserConstants.LOGICAL_LT: case ParserConstants.LOGICAL_LE: case ParserConstants.LOGICAL_GT: case ParserConstants.LOGICAL_GE:
			;
			break;

		    default:
			jj_la1[41] = jj_gen;
			//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
			goto label_16_brk;

		}
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.LOGICAL_LT:
			jj_consume_token(ParserConstants.LOGICAL_LT);
			ASTLTNode jjtn001 = new ASTLTNode(this, ParserTreeConstants.JJTLTNODE);
			bool jjtc001 = true;
			jjtree.openNodeScope(jjtn001);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try {
			    AdditiveExpression();
			} catch (System.Exception jjte001) {
			    if (jjtc001) {
				jjtree.clearNodeScope(jjtn001);
				jjtc001 = false;
			    } else {
				jjtree.popNode();
			    }
			    if (jjte001 is System.SystemException) { {
				    if (true)
					throw (System.SystemException) jjte001;
				}
			    }
			    if (jjte001 is ParseException) { {
				    if (true)
					throw (ParseException) jjte001;
				}
			    } {
				if (true)
				    throw (System.ApplicationException) jjte001;
			    }
			} finally {
			    if (jjtc001) {
				jjtree.closeNodeScope(jjtn001, 2);
			    }
			}
			break;

		    case ParserConstants.LOGICAL_GT:
			jj_consume_token(ParserConstants.LOGICAL_GT);
			ASTGTNode jjtn002 = new ASTGTNode(this, ParserTreeConstants.JJTGTNODE);
			bool jjtc002 = true;
			jjtree.openNodeScope(jjtn002);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try {
			    AdditiveExpression();
			} catch (System.Exception jjte002) {
			    if (jjtc002) {
				jjtree.clearNodeScope(jjtn002);
				jjtc002 = false;
			    } else {
				jjtree.popNode();
			    }
			    if (jjte002 is System.SystemException) { {
				    if (true)
					throw (System.SystemException) jjte002;
				}
			    }
			    if (jjte002 is ParseException) { {
				    if (true)
					throw (ParseException) jjte002;
				}
			    } {
				if (true)
				    throw (System.ApplicationException) jjte002;
			    }
			} finally {
			    if (jjtc002) {
				jjtree.closeNodeScope(jjtn002, 2);
			    }
			}
			break;

		    case ParserConstants.LOGICAL_LE:
			jj_consume_token(ParserConstants.LOGICAL_LE);
			ASTLENode jjtn003 = new ASTLENode(this, ParserTreeConstants.JJTLENODE);
			bool jjtc003 = true;
			jjtree.openNodeScope(jjtn003);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try {
			    AdditiveExpression();
			} catch (System.Exception jjte003) {
			    if (jjtc003) {
				jjtree.clearNodeScope(jjtn003);
				jjtc003 = false;
			    } else {
				jjtree.popNode();
			    }
			    if (jjte003 is System.SystemException) { {
				    if (true)
					throw (System.SystemException) jjte003;
				}
			    }
			    if (jjte003 is ParseException) { {
				    if (true)
					throw (ParseException) jjte003;
				}
			    } {
				if (true)
				    throw (System.ApplicationException) jjte003;
			    }
			} finally {
			    if (jjtc003) {
				jjtree.closeNodeScope(jjtn003, 2);
			    }
			}
			break;

		    case ParserConstants.LOGICAL_GE:
			jj_consume_token(ParserConstants.LOGICAL_GE);
			ASTGENode jjtn004 = new ASTGENode(this, ParserTreeConstants.JJTGENODE);
			bool jjtc004 = true;
			jjtree.openNodeScope(jjtn004);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try {
			    AdditiveExpression();
			} catch (System.Exception jjte004) {
			    if (jjtc004) {
				jjtree.clearNodeScope(jjtn004);
				jjtc004 = false;
			    } else {
				jjtree.popNode();
			    }
			    if (jjte004 is System.SystemException) { {
				    if (true)
					throw (System.SystemException) jjte004;
				}
			    }
			    if (jjte004 is ParseException) { {
				    if (true)
					throw (ParseException) jjte004;
				}
			    } {
				if (true)
				    throw (System.ApplicationException) jjte004;
			    }
			} finally {
			    if (jjtc004) {
				jjtree.closeNodeScope(jjtn004, 2);
			    }
			}
			break;

		    default:
			jj_la1[42] = jj_gen;
			jj_consume_token(- 1);
			throw new ParseException();

		}
	    }
	    //UPGRADE_NOTE: Label 'label_16_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_16_brk:
	    ;

	}

	public void  AdditiveExpression() {
	    MultiplicativeExpression();
	    while (true) {
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		case ParserConstants.MINUS: case ParserConstants.PLUS:
			;
			break;

		    default:
			jj_la1[43] = jj_gen;
			//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
			goto label_17_brk;

		}
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.PLUS:
			jj_consume_token(ParserConstants.PLUS);
			ASTAddNode jjtn001 = new ASTAddNode(this, ParserTreeConstants.JJTADDNODE);
			bool jjtc001 = true;
			jjtree.openNodeScope(jjtn001);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try {
			    MultiplicativeExpression();
			} catch (System.Exception jjte001) {
			    if (jjtc001) {
				jjtree.clearNodeScope(jjtn001);
				jjtc001 = false;
			    } else {
				jjtree.popNode();
			    }
			    if (jjte001 is System.SystemException) { {
				    if (true)
					throw (System.SystemException) jjte001;
				}
			    }
			    if (jjte001 is ParseException) { {
				    if (true)
					throw (ParseException) jjte001;
				}
			    } {
				if (true)
				    throw (System.ApplicationException) jjte001;
			    }
			} finally {
			    if (jjtc001) {
				jjtree.closeNodeScope(jjtn001, 2);
			    }
			}
			break;

		    case ParserConstants.MINUS:
			jj_consume_token(ParserConstants.MINUS);
			ASTSubtractNode jjtn002 = new ASTSubtractNode(this, ParserTreeConstants.JJTSUBTRACTNODE);
			bool jjtc002 = true;
			jjtree.openNodeScope(jjtn002);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try {
			    MultiplicativeExpression();
			} catch (System.Exception jjte002) {
			    if (jjtc002) {
				jjtree.clearNodeScope(jjtn002);
				jjtc002 = false;
			    } else {
				jjtree.popNode();
			    }
			    if (jjte002 is System.SystemException) { {
				    if (true)
					throw (System.SystemException) jjte002;
				}
			    }
			    if (jjte002 is ParseException) { {
				    if (true)
					throw (ParseException) jjte002;
				}
			    } {
				if (true)
				    throw (System.ApplicationException) jjte002;
			    }
			} finally {
			    if (jjtc002) {
				jjtree.closeNodeScope(jjtn002, 2);
			    }
			}
			break;

		    default:
			jj_la1[44] = jj_gen;
			jj_consume_token(- 1);
			throw new ParseException();

		}
	    }
	    //UPGRADE_NOTE: Label 'label_17_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_17_brk:
	    ;

	}

	public void  MultiplicativeExpression() {
	    UnaryExpression();
	    while (true) {
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
	    case ParserConstants.MULTIPLY: case ParserConstants.DIVIDE: case ParserConstants.MODULUS:
			;
			break;

		    default:
			jj_la1[45] = jj_gen;
			//UPGRADE_NOTE: Labeled break statement was changed to a goto statement. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1012"'
			goto label_18_brk;

		}
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.MULTIPLY:
			jj_consume_token(ParserConstants.MULTIPLY);
			ASTMulNode jjtn001 = new ASTMulNode(this, ParserTreeConstants.JJTMULNODE);
			bool jjtc001 = true;
			jjtree.openNodeScope(jjtn001);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try {
			    UnaryExpression();
			} catch (System.Exception jjte001) {
			    if (jjtc001) {
				jjtree.clearNodeScope(jjtn001);
				jjtc001 = false;
			    } else {
				jjtree.popNode();
			    }
			    if (jjte001 is System.SystemException) { {
				    if (true)
					throw (System.SystemException) jjte001;
				}
			    }
			    if (jjte001 is ParseException) { {
				    if (true)
					throw (ParseException) jjte001;
				}
			    } {
				if (true)
				    throw (System.ApplicationException) jjte001;
			    }
			} finally {
			    if (jjtc001) {
				jjtree.closeNodeScope(jjtn001, 2);
			    }
			}
			break;

		    case ParserConstants.DIVIDE:
			jj_consume_token(ParserConstants.DIVIDE);
			ASTDivNode jjtn002 = new ASTDivNode(this, ParserTreeConstants.JJTDIVNODE);
			bool jjtc002 = true;
			jjtree.openNodeScope(jjtn002);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try {
			    UnaryExpression();
			} catch (System.Exception jjte002) {
			    if (jjtc002) {
				jjtree.clearNodeScope(jjtn002);
				jjtc002 = false;
			    } else {
				jjtree.popNode();
			    }
			    if (jjte002 is System.SystemException) { {
				    if (true)
					throw (System.SystemException) jjte002;
				}
			    }
			    if (jjte002 is ParseException) { {
				    if (true)
					throw (ParseException) jjte002;
				}
			    } {
				if (true)
				    throw (System.ApplicationException) jjte002;
			    }
			} finally {
			    if (jjtc002) {
				jjtree.closeNodeScope(jjtn002, 2);
			    }
			}
			break;

		    case ParserConstants.MODULUS:
			jj_consume_token(ParserConstants.MODULUS);
			ASTModNode jjtn003 = new ASTModNode(this, ParserTreeConstants.JJTMODNODE);
			bool jjtc003 = true;
			jjtree.openNodeScope(jjtn003);
			//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
			try {
			    UnaryExpression();
			} catch (System.Exception jjte003) {
			    if (jjtc003) {
				jjtree.clearNodeScope(jjtn003);
				jjtc003 = false;
			    } else {
				jjtree.popNode();
			    }
			    if (jjte003 is System.SystemException) { {
				    if (true)
					throw (System.SystemException) jjte003;
				}
			    }
			    if (jjte003 is ParseException) { {
				    if (true)
					throw (ParseException) jjte003;
				}
			    } {
				if (true)
				    throw (System.ApplicationException) jjte003;
			    }
			} finally {
			    if (jjtc003) {
				jjtree.closeNodeScope(jjtn003, 2);
			    }
			}
			break;

		    default:
			jj_la1[46] = jj_gen;
			jj_consume_token(- 1);
			throw new ParseException();

		}
	    }
	    //UPGRADE_NOTE: Label 'label_18_brk' was added. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1011"'
label_18_brk:
	    ;

	}

	public void  UnaryExpression() {
	    if (jj_2_11(2)) {
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		    case ParserConstants.WHITESPACE:
			jj_consume_token(ParserConstants.WHITESPACE);
			break;

		    default:
			jj_la1[47] = jj_gen;
			;
			break;

		}
		jj_consume_token(ParserConstants.LOGICAL_NOT);
		ASTNotNode jjtn001 = new ASTNotNode(this, ParserTreeConstants.JJTNOTNODE);
		bool jjtc001 = true;
		jjtree.openNodeScope(jjtn001);
		//UPGRADE_NOTE: Exception 'java.lang.Throwable' was converted to ' ' which has different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1100"'
		try {
		    UnaryExpression();
		} catch (System.Exception jjte001) {
		    if (jjtc001) {
			jjtree.clearNodeScope(jjtn001);
			jjtc001 = false;
		    } else {
			jjtree.popNode();
		    }
		    if (jjte001 is System.SystemException) { {
			    if (true)
				throw (System.SystemException) jjte001;
			}
		    }
		    if (jjte001 is ParseException) { {
			    if (true)
				throw (ParseException) jjte001;
			}
		    } {
			if (true)
			    throw (System.ApplicationException) jjte001;
		    }
		} finally {
		    if (jjtc001) {
			jjtree.closeNodeScope(jjtn001, 1);
		    }
		}
	    } else {
		switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
case ParserConstants.LBRACKET: case ParserConstants.LPAREN: case ParserConstants.WHITESPACE: case ParserConstants.STRING_LITERAL: case ParserConstants.TRUE: case ParserConstants.FALSE: case ParserConstants.NUMBER_LITERAL: case ParserConstants.IDENTIFIER: case ParserConstants.LCURLY:
			PrimaryExpression();
			break;

		    default:
			jj_la1[48] = jj_gen;
			jj_consume_token(- 1);
			throw new ParseException();

		}
	    }
	}

	public void  PrimaryExpression() {
	    switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		case ParserConstants.WHITESPACE:
		    jj_consume_token(ParserConstants.WHITESPACE);
		    break;

		default:
		    jj_la1[49] = jj_gen;
		    ;
		    break;

	    }
	    switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		case ParserConstants.STRING_LITERAL:
		    StringLiteral();
		    break;

		case ParserConstants.NUMBER_LITERAL:
		    NumberLiteral();
		    break;

		case ParserConstants.IDENTIFIER:
		case ParserConstants.LCURLY:
		    Reference();
		    break;

		default:
		    jj_la1[50] = jj_gen;
		    if (jj_2_12(2147483647)) {
			IntegerRange();
		    } else {
			switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
			    case ParserConstants.LBRACKET:
				ObjectArray();
				break;

			    case ParserConstants.TRUE:
				True();
				break;

			    case ParserConstants.FALSE:
				False();
				break;

			    case ParserConstants.LPAREN:
				jj_consume_token(ParserConstants.LPAREN);
				Expression();
				jj_consume_token(ParserConstants.RPAREN);
				break;

			    default:
				jj_la1[51] = jj_gen;
				jj_consume_token(- 1);
				throw new ParseException();

			}
		    }
		    break;

	    }
	    switch ((jj_ntk_Renamed_Field == - 1)?jj_ntk():jj_ntk_Renamed_Field) {
		case ParserConstants.WHITESPACE:
		    jj_consume_token(ParserConstants.WHITESPACE);
		    break;

		default:
		    jj_la1[52] = jj_gen;
		    ;
		    break;

	    }
	}

	private bool jj_2_1(int xla) {
	    jj_la = xla;
	    jj_lastpos = jj_scanpos = token;
	    bool retval = !jj_3_1();
	    jj_save(0, xla);
	    return retval;
	}

	private bool jj_2_2(int xla) {
	    jj_la = xla;
	    jj_lastpos = jj_scanpos = token;
	    bool retval = !jj_3_2();
	    jj_save(1, xla);
	    return retval;
	}

	private bool jj_2_3(int xla) {
	    jj_la = xla;
	    jj_lastpos = jj_scanpos = token;
	    bool retval = !jj_3_3();
	    jj_save(2, xla);
	    return retval;
	}

	private bool jj_2_4(int xla) {
	    jj_la = xla;
	    jj_lastpos = jj_scanpos = token;
	    bool retval = !jj_3_4();
	    jj_save(3, xla);
	    return retval;
	}

	private bool jj_2_5(int xla) {
	    jj_la = xla;
	    jj_lastpos = jj_scanpos = token;
	    bool retval = !jj_3_5();
	    jj_save(4, xla);
	    return retval;
	}

	private bool jj_2_6(int xla) {
	    jj_la = xla;
	    jj_lastpos = jj_scanpos = token;
	    bool retval = !jj_3_6();
	    jj_save(5, xla);
	    return retval;
	}

	private bool jj_2_7(int xla) {
	    jj_la = xla;
	    jj_lastpos = jj_scanpos = token;
	    bool retval = !jj_3_7();
	    jj_save(6, xla);
	    return retval;
	}

	private bool jj_2_8(int xla) {
	    jj_la = xla;
	    jj_lastpos = jj_scanpos = token;
	    bool retval = !jj_3_8();
	    jj_save(7, xla);
	    return retval;
	}

	private bool jj_2_9(int xla) {
	    jj_la = xla;
	    jj_lastpos = jj_scanpos = token;
	    bool retval = !jj_3_9();
	    jj_save(8, xla);
	    return retval;
	}

	private bool jj_2_10(int xla) {
	    jj_la = xla;
	    jj_lastpos = jj_scanpos = token;
	    bool retval = !jj_3_10();
	    jj_save(9, xla);
	    return retval;
	}

	private bool jj_2_11(int xla) {
	    jj_la = xla;
	    jj_lastpos = jj_scanpos = token;
	    bool retval = !jj_3_11();
	    jj_save(10, xla);
	    return retval;
	}

	private bool jj_2_12(int xla) {
	    jj_la = xla;
	    jj_lastpos = jj_scanpos = token;
	    bool retval = !jj_3_12();
	    jj_save(11, xla);
	    return retval;
	}

	private bool jj_3R_58() {
	    if (jj_scan_token(ParserConstants.TRUE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3_7() {
	    if (jj_scan_token(ParserConstants.DOT))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3_8()) {
		jj_scanpos = xsp;
		if (jj_3R_30())
		    return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_42() {
	    if (jj_3R_54())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    while (true) {
		xsp = jj_scanpos;
		if (jj_3R_88()) {
		    jj_scanpos = xsp;
		    break;
		}
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    }
	    return false;
	}

	private bool jj_3_5() {
	    if (jj_scan_token(ParserConstants.DOT))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3_6()) {
		jj_scanpos = xsp;
		if (jj_3R_28())
		    return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_39() {
	    if (jj_scan_token(ParserConstants.LCURLY))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_scan_token(ParserConstants.IDENTIFIER))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    while (true) {
		xsp = jj_scanpos;
		if (jj_3_7()) {
		    jj_scanpos = xsp;
		    break;
		}
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    }
	    if (jj_scan_token(ParserConstants.RCURLY))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3_12() {
	    if (jj_scan_token(ParserConstants.LBRACKET))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3R_34())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    xsp = jj_scanpos;
	    if (jj_3R_35()) {
		jj_scanpos = xsp;
		if (jj_3R_36())
		    return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    xsp = jj_scanpos;
	    if (jj_3R_37())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_scan_token(ParserConstants.DOUBLEDOT))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_24() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_38() {
	    if (jj_scan_token(ParserConstants.IDENTIFIER))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    while (true) {
		xsp = jj_scanpos;
		if (jj_3_5()) {
		    jj_scanpos = xsp;
		    break;
		}
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    }
	    return false;
	}

	private bool jj_3R_52() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_51() {
	    if (jj_scan_token(ParserConstants.LPAREN))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_60())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_scan_token(ParserConstants.RPAREN))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_19() {
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3R_38()) {
		jj_scanpos = xsp;
		if (jj_3R_39())
		    return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_32() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_50() {
	    if (jj_3R_59())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_41() {
	    if (jj_scan_token(ParserConstants.IDENTIFIER))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_49() {
	    if (jj_3R_58())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_48() {
	    if (jj_3R_57())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_47() {
	    if (jj_3R_56())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_46() {
	    if (jj_3R_19())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_45() {
	    if (jj_3R_40())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3_4() {
	    if (jj_scan_token(ParserConstants.LBRACKET))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3R_24())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    xsp = jj_scanpos;
	    if (jj_3R_25()) {
		jj_scanpos = xsp;
		if (jj_3R_26())
		    return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    xsp = jj_scanpos;
	    if (jj_3R_27())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_scan_token(ParserConstants.DOUBLEDOT))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_44() {
	    if (jj_3R_55())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_29() {
	    if (jj_3R_41())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_scan_token(ParserConstants.LPAREN))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3R_42())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_scan_token(ParserConstants.REFMOD2_RPAREN))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_43() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_31() {
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3R_43())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    xsp = jj_scanpos;
	    if (jj_3R_44()) {
		jj_scanpos = xsp;
		if (jj_3R_45()) {
		    jj_scanpos = xsp;
		    if (jj_3R_46()) {
			jj_scanpos = xsp;
			if (jj_3R_47()) {
			    jj_scanpos = xsp;
			    if (jj_3R_48()) {
				jj_scanpos = xsp;
				if (jj_3R_49()) {
				    jj_scanpos = xsp;
				    if (jj_3R_50()) {
					jj_scanpos = xsp;
					if (jj_3R_51())
					    return true;
					if (jj_la == 0 && jj_scanpos == jj_lastpos)
					    return false;
				    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
				} else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				    return false;
			    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			} else if (jj_la == 0 && jj_scanpos == jj_lastpos)
			    return false;
		    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		} else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    xsp = jj_scanpos;
	    if (jj_3R_52())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_73() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_68() {
	    if (jj_3R_40())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_106() {
	    if (jj_scan_token(ParserConstants.MODULUS))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_33())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_67() {
	    if (jj_3R_19())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_105() {
	    if (jj_scan_token(ParserConstants.DIVIDE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_33())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_83() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_66() {
	    if (jj_3R_59())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_33() {
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3_11()) {
		jj_scanpos = xsp;
		if (jj_3R_53())
		    return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3_11() {
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3R_32())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_scan_token(ParserConstants.LOGICAL_NOT))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_33())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_53() {
	    if (jj_3R_31())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_104() {
	    if (jj_scan_token(ParserConstants.MULTIPLY))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_33())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_101() {
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3R_104()) {
		jj_scanpos = xsp;
		if (jj_3R_105()) {
		    jj_scanpos = xsp;
		    if (jj_3R_106())
			return true;
		    if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		} else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_65() {
	    if (jj_3R_58())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_55() {
	    if (jj_scan_token(ParserConstants.STRING_LITERAL))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_64() {
	    if (jj_3R_57())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_63() {
	    if (jj_3R_56())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_62() {
	    if (jj_3R_55())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_40() {
	    if (jj_scan_token(ParserConstants.NUMBER_LITERAL))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_75() {
	    if (jj_3R_40())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_80() {
	    if (jj_scan_token(ParserConstants.COMMA))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_54())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_71() {
	    if (jj_3R_40())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_95() {
	    if (jj_3R_33())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    while (true) {
		xsp = jj_scanpos;
		if (jj_3R_101()) {
		    jj_scanpos = xsp;
		    break;
		}
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    }
	    return false;
	}

	private bool jj_3R_61() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_54() {
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3R_61())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    xsp = jj_scanpos;
	    if (jj_3R_62()) {
		jj_scanpos = xsp;
		if (jj_3R_63()) {
		    jj_scanpos = xsp;
		    if (jj_3R_64()) {
			jj_scanpos = xsp;
			if (jj_3R_65()) {
			    jj_scanpos = xsp;
			    if (jj_3R_66()) {
				jj_scanpos = xsp;
				if (jj_3R_67()) {
				    jj_scanpos = xsp;
				    if (jj_3R_68())
					return true;
				    if (jj_la == 0 && jj_scanpos == jj_lastpos)
					return false;
				} else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				    return false;
			    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
				return false;
			} else if (jj_la == 0 && jj_scanpos == jj_lastpos)
			    return false;
		    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		} else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    xsp = jj_scanpos;
	    if (jj_3R_83())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_103() {
	    if (jj_scan_token(ParserConstants.MINUS))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_95())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_102() {
	    if (jj_scan_token(ParserConstants.PLUS))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_95())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_96() {
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3R_102()) {
		jj_scanpos = xsp;
		if (jj_3R_103())
		    return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_69() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_91() {
	    if (jj_3R_95())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    while (true) {
		xsp = jj_scanpos;
		if (jj_3R_96()) {
		    jj_scanpos = xsp;
		    break;
		}
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    }
	    return false;
	}

	private bool jj_3R_100() {
	    if (jj_scan_token(ParserConstants.LOGICAL_GE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_91())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_76() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_99() {
	    if (jj_scan_token(ParserConstants.LOGICAL_LE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_91())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_74() {
	    if (jj_3R_19())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_98() {
	    if (jj_scan_token(ParserConstants.LOGICAL_GT))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_91())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_70() {
	    if (jj_3R_19())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_72() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_77() {
	    if (jj_3R_54())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    while (true) {
		xsp = jj_scanpos;
		if (jj_3R_80()) {
		    jj_scanpos = xsp;
		    break;
		}
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    }
	    return false;
	}

	private bool jj_3R_97() {
	    if (jj_scan_token(ParserConstants.LOGICAL_LT))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_91())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_92() {
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3R_97()) {
		jj_scanpos = xsp;
		if (jj_3R_98()) {
		    jj_scanpos = xsp;
		    if (jj_3R_99()) {
			jj_scanpos = xsp;
			if (jj_3R_100())
			    return true;
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
			    return false;
		    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
			return false;
		} else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_56() {
	    if (jj_scan_token(ParserConstants.LBRACKET))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3R_69())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    xsp = jj_scanpos;
	    if (jj_3R_70()) {
		jj_scanpos = xsp;
		if (jj_3R_71())
		    return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    xsp = jj_scanpos;
	    if (jj_3R_72())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_scan_token(ParserConstants.DOUBLEDOT))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    xsp = jj_scanpos;
	    if (jj_3R_73())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    xsp = jj_scanpos;
	    if (jj_3R_74()) {
		jj_scanpos = xsp;
		if (jj_3R_75())
		    return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    xsp = jj_scanpos;
	    if (jj_3R_76())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_scan_token(ParserConstants.RBRACKET))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_89() {
	    if (jj_3R_91())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    while (true) {
		xsp = jj_scanpos;
		if (jj_3R_92()) {
		    jj_scanpos = xsp;
		    break;
		}
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    }
	    return false;
	}

	private bool jj_3R_94() {
	    if (jj_scan_token(ParserConstants.LOGICAL_NOT_EQUALS))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_89())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_93() {
	    if (jj_scan_token(ParserConstants.LOGICAL_EQUALS))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_89())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_90() {
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3R_93()) {
		jj_scanpos = xsp;
		if (jj_3R_94())
		    return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_57() {
	    if (jj_scan_token(ParserConstants.LBRACKET))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3R_77())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_scan_token(ParserConstants.RBRACKET))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_86() {
	    if (jj_3R_89())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    while (true) {
		xsp = jj_scanpos;
		if (jj_3R_90()) {
		    jj_scanpos = xsp;
		    break;
		}
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    }
	    return false;
	}

	private bool jj_3R_87() {
	    if (jj_scan_token(ParserConstants.LOGICAL_AND))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_86())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_84() {
	    if (jj_3R_86())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    while (true) {
		xsp = jj_scanpos;
		if (jj_3R_87()) {
		    jj_scanpos = xsp;
		    break;
		}
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    }
	    return false;
	}

	private bool jj_3R_85() {
	    if (jj_scan_token(ParserConstants.LOGICAL_OR))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_84())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3_2() {
	    if (jj_scan_token(ParserConstants.DOUBLE_ESCAPE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3_10() {
	    if (jj_3R_31())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_scan_token(ParserConstants.EQUALS))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_82() {
	    if (jj_3R_84())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    while (true) {
		xsp = jj_scanpos;
		if (jj_3R_85()) {
		    jj_scanpos = xsp;
		    break;
		}
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    }
	    return false;
	}

	private bool jj_3R_81() {
	    if (jj_3R_31())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_scan_token(ParserConstants.EQUALS))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_60())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_79() {
	    if (jj_3R_82())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_78() {
	    if (jj_3R_81())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_60() {
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3R_78()) {
		jj_scanpos = xsp;
		if (jj_3R_79())
		    return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_23() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3_9() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3_1() {
	    if (jj_3R_19())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_22() {
	    if (jj_3R_40())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_37() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_21() {
	    if (jj_3R_19())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_27() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_30() {
	    if (jj_3R_41())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_28() {
	    if (jj_3R_41())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_36() {
	    if (jj_3R_40())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_20() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_35() {
	    if (jj_3R_19())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_26() {
	    if (jj_3R_40())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3_8() {
	    if (jj_3R_29())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3_3() {
	    if (jj_scan_token(ParserConstants.LBRACKET))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    Token xsp;
	    xsp = jj_scanpos;
	    if (jj_3R_20())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    xsp = jj_scanpos;
	    if (jj_3R_21()) {
		jj_scanpos = xsp;
		if (jj_3R_22())
		    return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
		    return false;
	    } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    xsp = jj_scanpos;
	    if (jj_3R_23())
		jj_scanpos = xsp;
	    else if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_scan_token(ParserConstants.DOUBLEDOT))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_88() {
	    if (jj_scan_token(ParserConstants.COMMA))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    if (jj_3R_54())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3_6() {
	    if (jj_3R_29())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_25() {
	    if (jj_3R_19())
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_59() {
	    if (jj_scan_token(ParserConstants.FALSE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	private bool jj_3R_34() {
	    if (jj_scan_token(ParserConstants.WHITESPACE))
		return true;
	    if (jj_la == 0 && jj_scanpos == jj_lastpos)
		return false;
	    return false;
	}

	public ParserTokenManager token_source;
	public Token token, jj_nt;
	//UPGRADE_NOTE: Field jj_ntk was renamed. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1029"'
	private int jj_ntk_Renamed_Field;
	private Token jj_scanpos, jj_lastpos;
	private int jj_la;
	public bool lookingAhead = false;
	private bool jj_semLA;
	private int jj_gen;
	//UPGRADE_NOTE: Final was removed from the declaration of 'jj_la1 '. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1003"'
	//UPGRADE_NOTE: The initialization of  'jj_la1' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
	private int[] jj_la1;
	//UPGRADE_NOTE: Final was removed from the declaration of 'jj_la1_0 '. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1003"'
	private int[] jj_la1_0 = new int[]{0x13f0360, 0x0, 0x13f0360, 0x380000, 0x1000000, 0x6800002, 0x800000, 0x7800002, 0x13f0360, 0x8, 0x7800002, 0x800000, 0x0, 0x800000, 0x800000, 0x0, 0x800000, 0x800000, 0x1000000, 0x6000002, 0x800000, 0x8, 0x7800002, 0x0, 0x0, 0x0, 0x1060060, 0x800000, 0x13f0360, 0x0, 0x0, 0x0, 0x13f0360, 0x800000, 0x13f0360, 0x8000000, 0x7800022, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30000000, 0x30000000, (int) (- (0x100000000 - 0xc0000000)), (int) (- (0x100000000 - 0xc0000000)), 0x800000, 0x7800022, 0x800000, 0x1000000, 0x6000022, 0x800000};
	//UPGRADE_NOTE: Final was removed from the declaration of 'jj_la1_1 '. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1003"'
	private int[] jj_la1_1 = new int[]{0xf129000, 0x9000, 0xe120000, 0x0, 0x5120000, 0x0, 0x0, 0x5120000, 0xf129000, 0x0, 0x5020000, 0x0, 0x5020000, 0x0, 0x0, 0x5020000, 0x0, 0x0, 0x0, 0x5020000, 0x0, 0x0, 0x5020000, 0x1000000, 0x1000000, 0x5000000, 0xe020000, 0x0, 0xf129000, 0x2000, 0x2000, 0x4000, 0xf129000, 0x0, 0xf129000, 0x0, 0x5020200, 0x4, 0x2, 0x180, 0x180, 0x78, 0x78, 0x0, 0x0, 0x1, 0x1, 0x0, 0x5020000, 0x0, 0x5020000, 0x0, 0x0};
	//UPGRADE_NOTE: Final was removed from the declaration of 'jj_2_rtns '. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1003"'
	//UPGRADE_NOTE: The initialization of  'jj_2_rtns' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
	private JJCalls[] jj_2_rtns;
	private bool jj_rescan = false;
	private int jj_gc = 0;

	public Parser(CharStream stream) {
	    InitBlock();
	    token_source = new ParserTokenManager(stream);
	    token = new Token();
	    jj_ntk_Renamed_Field = - 1;
	    jj_gen = 0;
	    for (int i = 0; i < 53; i++)
		jj_la1[i] = - 1;
	    for (int i = 0; i < jj_2_rtns.Length; i++)
		jj_2_rtns[i] = new JJCalls();
	}

	public virtual void  ReInit(CharStream stream) {
	    token_source.ReInit(stream);
	    token = new Token();
	    jj_ntk_Renamed_Field = - 1;
	    jjtree.reset();
	    jj_gen = 0;
	    for (int i = 0; i < 53; i++)
		jj_la1[i] = - 1;
	    for (int i = 0; i < jj_2_rtns.Length; i++)
		jj_2_rtns[i] = new JJCalls();
	}

	public Parser(ParserTokenManager tm) {
	    InitBlock();
	    token_source = tm;
	    token = new Token();
	    jj_ntk_Renamed_Field = - 1;
	    jj_gen = 0;
	    for (int i = 0; i < 53; i++)
		jj_la1[i] = - 1;
	    for (int i = 0; i < jj_2_rtns.Length; i++)
		jj_2_rtns[i] = new JJCalls();
	}

	public virtual void  ReInit(ParserTokenManager tm) {
	    token_source = tm;
	    token = new Token();
	    jj_ntk_Renamed_Field = - 1;
	    jjtree.reset();
	    jj_gen = 0;
	    for (int i = 0; i < 53; i++)
		jj_la1[i] = - 1;
	    for (int i = 0; i < jj_2_rtns.Length; i++)
		jj_2_rtns[i] = new JJCalls();
	}

	private Token jj_consume_token(int kind) {
	    Token oldToken = token;
	    if (token.next != null)
		token = token.next;
	    else
		token = token.next = token_source.NextToken;
	    jj_ntk_Renamed_Field = - 1;
	    if (token.kind == kind) {
		jj_gen++;
		if (++jj_gc > 100) {
		    jj_gc = 0;
		    for (int i = 0; i < jj_2_rtns.Length; i++) {
			JJCalls c = jj_2_rtns[i];
			while (c != null) {
			    if (c.gen < jj_gen)
				c.first = null;
			    c = c.next;
			}
		    }
		}
		return token;
	    }
	    token = oldToken;
	    jj_kind = kind;
	    throw generateParseException();
	}

	private bool jj_scan_token(int kind) {
	    if (jj_scanpos == jj_lastpos) {
		jj_la--;
		if (jj_scanpos.next == null) {
		    jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.NextToken;
		} else {
		    jj_lastpos = jj_scanpos = jj_scanpos.next;
		}
	    } else {
		jj_scanpos = jj_scanpos.next;
	    }
	    if (jj_rescan) {
		int i = 0;
		Token tok = token;
		while (tok != null && tok != jj_scanpos) {
		    i++;
		    tok = tok.next;
		}
		if (tok != null)
		    jj_add_error_token(kind, i);
	    }
	    return (jj_scanpos.kind != kind);
	}


	public Token getToken(int index) {
	    Token t = lookingAhead?jj_scanpos:token;
	    for (int i = 0; i < index; i++) {
		if (t.next != null)
		    t = t.next;
		else
		    t = t.next = token_source.NextToken;
	    }
	    return t;
	}

	private int jj_ntk() {
	    if ((jj_nt = token.next) == null)
		return (jj_ntk_Renamed_Field = (token.next = token_source.NextToken).kind);
	    else
		return (jj_ntk_Renamed_Field = jj_nt.kind);
	}

	//UPGRADE_NOTE: The initialization of  'jj_expentries' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
	private System.Collections.ArrayList jj_expentries;
	private int[] jj_expentry;
	private int jj_kind = - 1;
	//UPGRADE_NOTE: The initialization of  'jj_lasttokens' was moved to method 'InitBlock'. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1005"'
	private int[] jj_lasttokens;
	private int jj_endpos;

	private void  jj_add_error_token(int kind, int pos) {
	    if (pos >= 100)
		return ;
	    if (pos == jj_endpos + 1) {
		jj_lasttokens[jj_endpos++] = kind;
	    } else if (jj_endpos != 0) {
		jj_expentry = new int[jj_endpos];
		for (int i = 0; i < jj_endpos; i++) {
		    jj_expentry[i] = jj_lasttokens[i];
		}
		bool exists = false;
		//UPGRADE_TODO: method 'java.util.Enumeration.hasMoreElements' was converted to ' ' which has a different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1073_javautilEnumerationhasMoreElements"'
		for (System.Collections.IEnumerator enum_Renamed = jj_expentries.GetEnumerator(); enum_Renamed.MoveNext(); ) {
		    //UPGRADE_TODO: method 'java.util.Enumeration.nextElement' was converted to ' ' which has a different behavior. 'ms-help://MS.VSCC/commoner/redir/redirect.htm?keyword="jlca1073_javautilEnumerationnextElement"'
		    int[] oldentry = (int[]) (enum_Renamed.Current);
		    if (oldentry.Length == jj_expentry.Length) {
			exists = true;
			for (int i = 0; i < jj_expentry.Length; i++) {
			    if (oldentry[i] != jj_expentry[i]) {
				exists = false;
				break;
			    }
			}
			if (exists)
			    break;
		    }
		}
		if (!exists)
		    jj_expentries.Add(jj_expentry);
		if (pos != 0)
		    jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	    }
	}

	public ParseException generateParseException() {
	    System.Collections.ArrayList temp_arraylist;
	    temp_arraylist = jj_expentries;
	    temp_arraylist.RemoveRange(0, temp_arraylist.Count);
	    bool[] la1tokens = new bool[62];
	    for (int i = 0; i < 62; i++) {
		la1tokens[i] = false;
	    }
	    if (jj_kind >= 0) {
		la1tokens[jj_kind] = true;
		jj_kind = - 1;
	    }
	    for (int i = 0; i < 53; i++) {
		if (jj_la1[i] == jj_gen) {
		    for (int j = 0; j < 32; j++) {
			if ((jj_la1_0[i] & (1 << j)) != 0) {
			    la1tokens[j] = true;
			}
			if ((jj_la1_1[i] & (1 << j)) != 0) {
			    la1tokens[32 + j] = true;
			}
		    }
		}
	    }
	    for (int i = 0; i < 62; i++) {
		if (la1tokens[i]) {
		    jj_expentry = new int[1];
		    jj_expentry[0] = i;
		    jj_expentries.Add(jj_expentry);
		}
	    }
	    jj_endpos = 0;
	    jj_rescan_token();
	    jj_add_error_token(0, 0);
	    int[][] exptokseq = new int[jj_expentries.Count][];
	    for (int i = 0; i < jj_expentries.Count; i++) {
		exptokseq[i] = (int[]) jj_expentries[i];
	    }
	    return new ParseException(token, exptokseq, ParserConstants.tokenImage);
	}

	public void  enable_tracing() {}

	public void  disable_tracing() {}

	private void  jj_rescan_token() {
	    jj_rescan = true;
	    for (int i = 0; i < 12; i++) {
		JJCalls p = jj_2_rtns[i];
		do {
		    if (p.gen > jj_gen) {
			jj_la = p.arg;
			jj_lastpos = jj_scanpos = p.first;
			switch (i) {
			    case 0:
				jj_3_1();
				break;

			    case 1:
				jj_3_2();
				break;

			    case 2:
				jj_3_3();
				break;

			    case 3:
				jj_3_4();
				break;

			    case 4:
				jj_3_5();
				break;

			    case 5:
				jj_3_6();
				break;

			    case 6:
				jj_3_7();
				break;

			    case 7:
				jj_3_8();
				break;

			    case 8:
				jj_3_9();
				break;

			    case 9:
				jj_3_10();
				break;

			    case 10:
				jj_3_11();
				break;

			    case 11:
				jj_3_12();
				break;

			}
		    }
		    p = p.next;
		} while (p != null);
	    }
	    jj_rescan = false;
	}

	private void  jj_save(int index, int xla) {
	    JJCalls p = jj_2_rtns[index];
	    while (p.gen > jj_gen) {
		if (p.next == null) {
		    p = p.next = new JJCalls();
		    break;
		}
		p = p.next;
	    }
	    p.gen = jj_gen + xla - jj_la;
	    p.first = token;
	    p.arg = xla;
	}

	sealed class JJCalls {
	    internal int gen;
	    internal Token first;
	    internal int arg;
	    internal JJCalls next;
	}
    }
}
