<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<NDepend AppName="@PROJECTNAME@" Platform="DotNet">
	<OutputDir KeepHistoric="False" KeepXmlFiles="False" ViewReport="False">.\NDependOut</OutputDir>
	<Assemblies>
		@ASSEMBLIES@
	</Assemblies>
	<FrameworkAssemblies />
	<Dirs>
		<Dir>C:\Windows\Microsoft.NET\Framework\v2.0.50727</Dir>
		<Dir>C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.0</Dir>
		<Dir>C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.5</Dir>
		<Dir>@BUILDDIR@</Dir>
	</Dirs>
	<Report XslPath="">
		<Section Enabled="True">Application Metrics</Section>
		<Section Enabled="True">Assemblies Metrics</Section>
		<Section Enabled="True">VisualNDepend View</Section>
		<Section Enabled="True">Assemblies Abstractness vs. Instability</Section>
		<Section Enabled="True">Assemblies Dependencies</Section>
		<Section Enabled="True">Assemblies Dependencies Diagram</Section>
		<Section Enabled="True">Assemblies build order</Section>
		<Section Enabled="True">NDepend information and warnings</Section>
		<Section Enabled="True">CQL Queries and Constraints</Section>
		<Section Enabled="True">Types Metrics</Section>
		<Section Enabled="False">Types Dependencies</Section>
	</Report>
	<BuildComparisonSetting ProjectMode="DontCompare" BuildMode="MostRecentBuildAvailable" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="1" />
	<CoverageFiles UncoverableAttribute="" />
	<SourceFileRebasing FromPath="" ToPath="" />
	<CQLQueries>
		<CQLGroup Name="Code Quality" Active="True">
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Quick summary of methods to refactor&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS /*OUT OF "YourGeneratedCode" */ WHERE \r\n\r\n                                           // Metrics' definitions\r\n     (  NbLinesOfCode &gt; 30 OR              // http://www.ndepend.com/Metrics.aspx#NbLinesOfCode\r\n        NbILInstructions &gt; 200 OR          // http://www.ndepend.com/Metrics.aspx#NbILInstructions\r\n        CyclomaticComplexity &gt; 20 OR       // http://www.ndepend.com/Metrics.aspx#CC\r\n        ILCyclomaticComplexity &gt; 50 OR     // http://www.ndepend.com/Metrics.aspx#ILCC\r\n        ILNestingDepth &gt; 4 OR              // http://www.ndepend.com/Metrics.aspx#ILNestingDepth\r\n        NbParameters &gt; 5 OR                // http://www.ndepend.com/Metrics.aspx#NbParameters\r\n        NbVariables &gt; 8 OR                 // http://www.ndepend.com/Metrics.aspx#NbVariables\r\n        NbOverloads &gt; 6 )                  // http://www.ndepend.com/Metrics.aspx#NbOverloads\r\n     AND \r\n\r\n     // Here are some ways to avoid taking account of generated methods.\r\n     !( NameIs "InitializeComponent()" OR\r\n        // NDepend.CQL.GeneratedAttribute is defined in the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n        // You can define your own attribute to mark "Generated".\r\n        HasAttribute "OPTIONAL:NDepend.CQL.GeneratedAttribute") </CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods too big (NbLinesOfCode)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE NbLinesOfCode &gt; 30 ORDER BY NbLinesOfCode DESC\r\n// METHODS WHERE NbLinesOfCode &gt; 30 are extremely complex and \r\n// should be split in smaller methods \r\n// (except if they are automatically generated by a tool).\r\n// See the definition of the NbLinesOfCode metric here http://www.ndepend.com/Metrics.aspx#NbLinesOfCode</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods too big (NbILInstructions)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE NbILInstructions &gt; 200 ORDER BY NbILInstructions DESC\r\n// METHODS WHERE NbILInstructions &gt; 200 are extremely complex and \r\n// should be split in smaller methods \r\n// (except if they are automatically generated by a tool).\r\n// See the definition of the NbILInstructions metric here http://www.ndepend.com/Metrics.aspx#NbILInstructions</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods too complex (CyclomaticComplexity)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE CyclomaticComplexity &gt; 20 ORDER BY CyclomaticComplexity DESC\r\n// METHODS WHERE CyclomaticComplexity &gt; 15 are hard to understand and maintain.\r\n// METHODS WHERE CyclomaticComplexity &gt; 30 are extremely complex and should be split \r\n// in smaller methods (except if they are automatically generated by a tool).\r\n// See the definition of the CyclomaticComplexity metric here http://www.ndepend.com/Metrics.aspx#CC</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods too complex (ILCyclomaticComplexity)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE ILCyclomaticComplexity &gt; 40 ORDER BY ILCyclomaticComplexity DESC\r\n// METHODS WHERE ILCyclomaticComplexity &gt; 20 are hard to understand and maintain.\r\n// METHODS WHERE ILCyclomaticComplexity &gt; 40 are extremely complex and should be split \r\n// in smaller methods (except if they are automatically generated by a tool).\r\n// See the definition of the ILCyclomaticComplexity metric here http://www.ndepend.com/Metrics.aspx#ILCC</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods too complex (ILNestingDepth)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE ILNestingDepth &gt; 4 ORDER BY ILNestingDepth DESC\r\n// METHODS WHERE ILNestingDepth &gt; 4 are hard to understand and maintain. \r\n// METHODS WHERE ILNestingDepth &gt; 8 is higher than 8 are extremely complex and should be split in smaller methods \r\n// (except if they are automatically generated by a tool). \r\n// See the definition of the NbILInstructions metric here http://www.NDepend.com/Metrics.aspx#ILNestingDepth</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods poorly commented (PercentageComment)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE PercentageComment &lt; 20 AND NbLinesOfCode &gt; 10  ORDER BY PercentageComment ASC\r\n// METHODS WHERE %Comment &lt; 20 and that have at least 10 lines of code should be more commented.\r\n// See the definition of the PercentageComment metric here http://www.ndepend.com/Metrics.aspx#PercentageComment</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods with too many parameters (NbParameters)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE NbParameters &gt; 5 ORDER BY NbParameters DESC\r\n// METHODS WHERE NbParameters &gt; 5 might be painful to call and might degrade performance. \r\n// You should prefer using additional properties/fields to the declaring type to handle \r\n// numerous states. Another alternative is to provide a class or structure dedicated to \r\n// handle arguments passing (for example see the class System.Diagnostics.ProcessStartInfo \r\n// and the method System.Diagnostics.Process.Start(ProcessStartInfo))\r\n// See the definition of the NbParameters metric here http://www.ndepend.com/Metrics.aspx#NbParameters</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods with too many local variables (NbVariables)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE NbVariables &gt; 15 ORDER BY NbVariables DESC\r\n// METHODS WHERE NbVariables &gt; 8 are hard to understand and maintain.\r\n// METHODS WHERE NbVariables &gt; 15 are extremely complex and should be split in \r\n// smaller methods (except if they are automatically generated by a tool).\r\n// See the definition of the Nbvariables metric here http://www.ndepend.com/Metrics.aspx#Nbvariables</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods with too many overloads (NbOverloads)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE NbOverloads &gt; 6 ORDER BY NbOverloads DESC\r\n// METHODS WHERE NbParameters &gt; 6 might be a problem to maintain and provoke higher coupling than necessary. \r\n// This might also reveal a potential misused of the C# and VB.NET language that since C#3 and VB9 support \r\n// object initialization. This feature helps reducing the number of constructors of a class.\r\n// See the definition of the NbOverloads metric here http://www.ndepend.com/Metrics.aspx#NbOverloads</CQLQuery>
			<CQLGroup Name="Type Metrics" Active="True">
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types with too many methods&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE NbMethods &gt; 20 ORDER BY NbMethods DESC\r\n// TYPES WHERE NbMethods &gt; 20 might be hard to understand and maintain \r\n// but there might be cases where it is relevant to have a high value for NbMethods. \r\n// For example, the System.Windows.Forms.DataGridView standard class has more than 1000 methods.\r\n// See the definition of the NbMethods metric here http://www.ndepend.com/Metrics.aspx#NbMethods</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types with too many fields&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE NbFields &gt; 20 AND !IsEnumeration ORDER BY NbFields DESC\r\n// TYPES WHERE NbFields &gt; 20 AND !IsEnumeration might be hard to understand and maintain \r\n// but there might be cases where it is relevant to have a high value for NbFields. \r\n// For example, the System.Windows.Forms.Control standard class has more than 200 fields. \r\n// The value of the metric NbFields might be a better indicator of complex type.\r\n// See the definition of the NbFields metric here http://www.ndepend.com/Metrics.aspx#NbFields</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types with poor cohesion (LCOM)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE LCOM &gt; 0.8 AND NbFields &gt; 10 AND NbMethods &gt;10 ORDER BY LCOM DESC\r\n// TYPES WHERE LCOM &gt; 0.8 AND NbFields &gt; 10 AND NbMethods &gt;10 might be problematic. \r\n// However, it is very hard to avoid such non-cohesive types. The LCOMHS metric\r\n// is often considered as more efficient to detect non-cohesive types.\r\n// See the definition of the LCOM metric here http://www.ndepend.com/Metrics.aspx#LCOM</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types with poor cohesion (LCOMHS)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE LCOMHS &gt; 0.95 AND NbFields &gt; 10 AND NbMethods &gt;10 ORDER BY LCOMHS DESC\r\n// TYPES WHERE LCOMHS &gt; 1.0 AND NbFields &gt; 10 AND NbMethods &gt;10 should be avoided. \r\n// Note that this constraint is stronger than the constraint \r\n// TYPES WHERE LCOM &gt; 0.8 AND NbFields &gt; 10 AND NbMethods &gt;10. \r\n// See the definition of the LCOMHS metric here http://www.ndepend.com/Metrics.aspx#LCOMHS</CQLQuery>
			</CQLGroup>
		</CQLGroup>
		<CQLGroup Name="Design" Active="True">
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Assembly should not contain namespaces dependency cycles&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 ASSEMBLIES WHERE ContainsNamespaceDependencyCycle\r\n// Dependency cycles between namespaces must be avoided \r\n// in order to have a levelized and comprehensive design.\r\n// More info available on the screencast 'Reduce the complexity' http://s3.amazonaws.com/NDependOnlineDemos/NDependReducingComplexity_viewlet_swf.html\r\n// You can also read this article http://www.theserverside.net/tt/articles/showarticle.tss?id=ControllingDependencies</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Type should not have too many responsabilities (Efferent Coupling)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE TypeCe &gt; 50 ORDER BY TypeCe DESC \r\n// The Efferent Coupling (TypeCe) for a particular type is the number of types \r\n// it directly depends on. Notice that types declared in tier assemblies are taken into account. \r\n\r\n// Types that depends on too many others type (more than 50) are complex and have\r\n// more than one responsability. They are good candidate for refactoring.\r\n\r\n// More information available in this article:\r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/02/15/code-metrics-on-coupling-dead-code-design-flaws-and-re-engineering.aspx\r\n\r\n</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;A stateless type might be turned into a static type&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  SizeOfInst ==0 AND \r\n  NbInterfacesImplemented == 0 AND // To be accurate, this constraint doesn't take \r\n                                   // account of types that implement some interfaces.\r\n  !IsStatic AND \r\n  !IsGeneric AND \r\n  !IsInterface \r\n// It indicates stateless types that might eventually be turned into static classes.\r\n// See the definition of the SizeOfInst metric here http://www.ndepend.com/Metrics.aspx#SizeOfInst</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Class shouldn't be too deep in inheritance tree &lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE DepthOfInheritance &gt;= 6 ORDER BY DepthOfInheritance DESC \r\n// Branches too long in the derivation should be avoided.\r\n// See the definition of the DepthOfInheritance metric here http://www.ndepend.com/Metrics.aspx#DIT\r\n \r\n// You can discard specific classes with by-design high DepthOfInheritance with such condition for example:\r\n// AND !DeriveFrom "System.Windows.Forms.Form" </CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Class with no descendant should be sealed if possible&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  IsClass AND \r\n  NbChildren ==0 AND \r\n  !IsSealed AND \r\n  !IsStatic \r\n  // AND !IsPublic   : You might want to add this condition if you are developping a framework\r\n  //                   with classes that are intended to be sub-classed by your clients.\r\n  ORDER BY NbLinesOfCode</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Classes that are candidate to be turned into Structures&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  IsClass AND\r\n  SizeOfInst &lt;= 16 AND    // Structure instance must not be too big, else it degrades performance.\r\n  NbChildren == 0 AND     // Must not have children\r\n  DepthOfInheritance == 1 // Must derive directly from System.Object\r\n  // AND IsSealed    : You might want to add this condition to restreint the set.\r\n  // AND IsImmutable : Structures should be immutable type.\r\n  // AND !IsPublic   : You might want to add this condition if you are developping a framework\r\n  //                   with classes that are intended to be sub-classed by your clients.\r\n</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Avoid namespaces with few types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 NAMESPACES WHERE NbTypes &lt; 5 ORDER BY NbTypes ASC \r\n\r\n// Make sure that there is a logical organization to each of your namespaces, \r\n// and that there is a valid reason for putting types in a sparsely populated \r\n// namespace. Namespaces should contain types that are used together in most \r\n// scenarios. When their applications are mutually exclusive, types should be \r\n// located in separate namespaces</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Nested types should not be visible&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE IsNested AND !IsPrivate AND !IsInFrameworkAssembly \r\n\r\n// A nested type is a type declared within the scope of another type. \r\n// Nested types are useful for encapsulating private implementation details of the containing type. \r\n// Used for this purpose, nested types should not be externally visible. Do not use externally \r\n// visible nested types for logical grouping or to avoid name collisions; instead, use namespaces.</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Avoid empty interfaces&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE IsInterface AND NbMethods == 0\r\n\r\n// Interfaces define members that provide a behavior or usage contract. The functionality described by \r\n// the interface can be adopted by any type, regardless of where the type appears in the inheritance\r\n// hierarchy. A type implements an interface by providing implementations for the interface's members.\r\n// An empty interface does not define any members, and as such, does not define a contract that can be implemented.\r\n\r\n// If your design includes empty interfaces that types are expected to implement, you are probably using\r\n// an interface as a marker, or a way of identifying a group of types. If this identification will occur \r\n// at runtime, the correct way to accomplish this is to use a custom attribute. Use the presence or absence \r\n// of the attribute, or the attribute's properties, to identify the target types. If the identification must\r\n// occur at compile time, then using an empty interface is acceptable.</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Declare types in namespaces&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT NAMESPACES WHERE NameIs "" AND !IsInFrameworkAssembly \r\n\r\n// Types are declared within namespaces to prevent name collisions, and as a way of organizing related types \r\n// in an object hierarchy. Types outside any named namespace are in a global namespace that cannot be referenced in code.\r\n// If an anonymous namespace can be found, it means that it contains types outside of namespaces.</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Empty static constructor can be discarded&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE IsClassConstructor AND NbLinesOfCode == 0</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Assemblies with poor cohesion (RelationalCohesion)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 ASSEMBLIES WHERE RelationalCohesion &lt; 1.5 OR RelationalCohesion &gt; 4.0\r\n\r\n// As classes inside an assembly should be strongly related, \r\n// the cohesion should be high. On the other hand, a value which is too high may \r\n// indicate over-coupling. A good range for RelationalCohesion is 1.5 to 4.0.\r\n// See the definition of the RelationalCohesion metric here http://www.ndepend.com/Metrics.aspx#RelationalCohesion</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Assemblies that don't satisfy the Abstractness/Instability principle&lt;/Name&gt;\r\n\r\nWARN IF Percentage &gt; 15 IN SELECT ASSEMBLIES WHERE NormDistFromMainSeq &gt; 0.7 ORDER BY NormDistFromMainSeq DESC\r\n\r\n// See the definition of the NormDistFromMainSeq metric here http://www.ndepend.com/Metrics.aspx#DitFromMainSeq</CQLQuery>
			<CQLGroup Name="Performance" Active="True">
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Instances size shouldn't be too big (SizeOfInst)&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE SizeOfInst &gt; 64 ORDER BY SizeOfInst DESC\r\n// TYPES WHERE SizeOfInst &gt; 64 might degrade performance (depending on the number of \r\n// instances created at runtime) and might be hard to maintain. \r\n// However it is not a rule since sometime there is no alternative \r\n// (the size of instances of the System.Net.NetworkInformation.SystemIcmpV6Statistics \r\n// standard class is 2064 bytes).\r\n// See the definition of the SizeOfInst metric here http://www.ndepend.com/Metrics.aspx#SizeOfInst</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Boxing/unboxing should be avoided (Method)&lt;/Name&gt;\r\nWARN IF Percentage &gt; 5 IN SELECT METHODS WHERE IsUsingBoxing OR IsUsingUnboxing \r\n// Thanks to generics, boxing and unboxing should be rare.</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Boxing/unboxing should be avoided (Type)&lt;/Name&gt;\r\nWARN IF Percentage &gt; 5 IN SELECT TYPES WHERE IsUsingBoxing OR IsUsingUnboxing \r\n// Thanks to generics, boxing and unboxing should be rare.</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Attribute classes should be sealed&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE IsAttributeClass \r\nAND !IsSealed AND !IsAbstract AND IsPublic AND !IsInFrameworkAssembly \r\n\r\n// The .NET Framework class library provides methods for retrieving custom attributes. \r\n// By default, these methods search the attribute inheritance hierarchy; for example \r\n// System.Attribute.GetCustomAttribute searches for the specified attribute type, or \r\n// any attribute type that extends the specified attribute type. Sealing the attribute \r\n// eliminates the search through the inheritance hierarchy, and can improve performance.</CQLQuery>
			</CQLGroup>
		</CQLGroup>
		<CQLGroup Name="Unused Code / Dead Code" Active="True">
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Potentially unused methods&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n MethodCa == 0 AND            // Ca=0 -&gt; No Afferent Coupling -&gt; The method is not used in the context of this application.\r\n !IsPublic AND                // Public methods might be used by client applications of your assemblies.\r\n !IsEntryPoint AND            // Main() method is not used by-design.\r\n !IsExplicitInterfaceImpl AND // The IL code never explicitely calls explicit interface methods implementation.\r\n !IsClassConstructor AND      // The IL code never explicitely calls class constructors.\r\n !IsFinalizer                 // The IL code never explicitely calls finalizers.\r\n</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Potentially unused fields&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n FieldCa == 0 AND  // Ca=0 -&gt; No Afferent Coupling -&gt; The field is not used in the context of this application.\r\n !IsPublic AND     // Although not recommended, public fields might be used by client applications of your assemblies.\r\n !IsLiteral AND    // The IL code never explicitely uses literal fields.\r\n !IsEnumValue AND  // The IL code never explicitely uses enumeration value.\r\n !NameIs "value__" // Field named 'value__' are relative to enumerations and the IL code never explicitely uses them.</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Potentially unused types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n TypeCa == 0 AND     // Ca=0 -&gt; No Afferent Coupling -&gt; The type is not used in the context of this application.\r\n !IsPublic AND       // Public types might be used by client applications of your assemblies.\r\n !NameIs "Program"   // Generally, types named Program contain a Main() entry-point method and this condition avoid to consider such type as unused code.\r\n</CQLQuery>
		</CQLGroup>
		<CQLGroup Name="Encapsulation" Active="True">
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields should be declared as private&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n !IsPrivate AND \r\n // These conditions filter cases where fields doesn't represent state that should be encapsulated. \r\n !IsInFrameworkAssembly AND \r\n !IsGeneratedByCompiler AND \r\n !IsSpecialName AND \r\n !IsInitOnly AND \r\n !IsLiteral AND \r\n !IsEnumValue</CQLQuery>
			<CQLGroup Name="Methods Optimal Encapsulation" Active="True">
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods that could be declared as 'internal' in C#,  'Friend' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE CouldBeInternal</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods that could be declared as 'protected internal' in C#,  'Protected Friend' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE CouldBeInternalProtected</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods that could be declared as 'protected' in C#,  'Protected' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE CouldBeProtected</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods that could be declared as 'private' in C#,  'Private' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE CouldBePrivate</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods that should be declared as 'public' in C#,  'Public' in VB.NET&lt;/Name&gt;\r\nSELECT METHODS WHERE ShouldBePublic \r\n// The keyword 'ShouldBePublic' shows code elements declared as 'internal\Friend' that are used outside of their assembly\r\n// thanks to the Attribute System.Runtime.CompilerServices.InternalsVisibleTo</CQLQuery>
			</CQLGroup>
			<CQLGroup Name="Types Optimal Encapsulation" Active="True">
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types that could be declared as internal&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE CouldBeInternal</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types that could be declared as 'protected internal' in C#,  'Protected Friend' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE CouldBeInternalProtected</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types that could be declared as 'protected' in C#,  'Protected' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE CouldBeProtected</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types that could be declared as 'private' in C#,  'Private' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE CouldBePrivate</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types that should be declared as 'public' in C#,  'Public' in VB.NET&lt;/Name&gt;\r\nSELECT TYPES WHERE ShouldBePublic \r\n// The keyword 'ShouldBePublic' shows code elements declared as 'internal\Friend' that are used outside of their assembly\r\n// thanks to the Attribute System.Runtime.CompilerServices.InternalsVisibleTo</CQLQuery>
			</CQLGroup>
			<CQLGroup Name="Fields Optimal Encapsulation" Active="True">
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields that could be declared as internal&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE CouldBeInternal</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields that could be declared as 'protected internal' in C#,  'Protected Friend' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE CouldBeInternalProtected</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields that could be declared as 'protected' in C#,  'Protected' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE CouldBeProtected</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields that could be declared as 'private' in C#,  'Private' in VB.NET&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE CouldBePrivate</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields that should be declared as 'public' in C#,  'Public' in VB.NET&lt;/Name&gt;\r\nSELECT FIELDS WHERE ShouldBePublic \r\n// The keyword 'ShouldBePublic' shows code elements declared as 'internal\Friend' that are used outside of their assembly\r\n// thanks to the Attribute System.Runtime.CompilerServices.InternalsVisibleTo</CQLQuery>
			</CQLGroup>
		</CQLGroup>
		<CQLGroup Name="Diff / Changes / Evolution" Active="True">
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;API Breaking Changes: Methods&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS\r\nWHERE IsPublic AND (VisibilityWasChanged OR WasRemoved)\r\n\r\n// This constraint warns if a public method is not public anymore or if it has been removed.\r\n// This can break the code of your clients.\r\n// More information on breaking changes here: \r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/20/avoid-api-breaking-changes.aspx\r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in VisualNDepend throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Analysis Comparison\r\n\r\n</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;API Breaking Changes: Types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES\r\nWHERE IsPublic AND (VisibilityWasChanged OR WasRemoved)\r\n\r\n// This constraint warns if a public type is not public anymore or if it has been removed.\r\n// This can break the code of your clients.\r\n// More information on breaking changes here: \r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/20/avoid-api-breaking-changes.aspx\r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in VisualNDepend throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Analysis Comparison\r\n\r\n\r\n</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;API Breaking Changes: Interfaces&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES\r\nWHERE IsInterface AND IsPublic AND (WasChanged AND !CommentsWereChanged)\r\n\r\n// This constraint warns if a public interface has been changed, but not because of comment change.\r\n// This can break the code of your clients that implements such interface.\r\n// More information on breaking changes here: \r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/20/avoid-api-breaking-changes.aspx\r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in VisualNDepend throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Analysis Comparison</CQLQuery>
			<CQLGroup Name="Changes Summary" Active="False">
				<CQLGroup Name="Methods" Active="False">
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods added&lt;/Name&gt;\r\nSELECT METHODS WHERE WasAdded\r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods removed&lt;/Name&gt;\r\nSELECT METHODS WHERE WasRemoved \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods where code was changed&lt;/Name&gt;\r\nSELECT METHODS WHERE CodeWasChanged \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods where comments were changed&lt;/Name&gt;\r\nSELECT METHODS WHERE CommentsWereChanged  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods where visibility was changed&lt;/Name&gt;\r\nSELECT METHODS WHERE VisibilityWasChanged  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods that became obsolete&lt;/Name&gt;\r\nSELECT METHODS WHERE BecameObsolete  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
				</CQLGroup>
				<CQLGroup Name="Fields" Active="False">
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Fields added&lt;/Name&gt;\r\nSELECT FIELDS WHERE WasAdded\r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Fields removed&lt;/Name&gt;\r\nSELECT FIELDS WHERE WasRemoved \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
				</CQLGroup>
				<CQLGroup Name="Types" Active="False">
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types added&lt;/Name&gt;\r\nSELECT TYPES WHERE WasAdded\r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types removed&lt;/Name&gt;\r\nSELECT TYPES WHERE WasRemoved \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types where code was changed&lt;/Name&gt;\r\nSELECT TYPES WHERE CodeWasChanged \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types where comments were changed&lt;/Name&gt;\r\nSELECT TYPES WHERE CommentsWereChanged  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types where visibility was changed&lt;/Name&gt;\r\nSELECT TYPES WHERE VisibilityWasChanged  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tyoes that became obsolete&lt;/Name&gt;\r\nSELECT TYPES WHERE BecameObsolete  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
				</CQLGroup>
				<CQLGroup Name="Namespaces" Active="False">
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces added&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE WasAdded\r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces removed&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE WasRemoved \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces where code was changed&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE CodeWasChanged \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces where comments were changed&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE CommentsWereChanged  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
				</CQLGroup>
				<CQLGroup Name="Assemblies" Active="False">
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies added&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE WasAdded\r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies removed&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE WasRemoved \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies where code was changed&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE CodeWasChanged \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies where comments were changed&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE CommentsWereChanged  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
				</CQLGroup>
				<CQLGroup Name="Tier Code Usage" Active="False">
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Methods that were not used and that are now used&lt;/Name&gt;\r\nSELECT METHODS WHERE IsUsedRecently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Methods that were used and that are not used anymore&lt;/Name&gt;\r\nSELECT METHODS WHERE IsNotUsedAnymore  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Types that were not used and that are now used&lt;/Name&gt;\r\nSELECT TYPES WHERE IsUsedRecently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Types that were used and that are not used anymore&lt;/Name&gt;\r\nSELECT TYPES WHERE IsNotUsedAnymore  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Types where usage changed&lt;/Name&gt;\r\nSELECT TYPES WHERE IsUsedDifferently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Namespaces that were not used and that are now used&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE IsUsedRecently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Namespaces that were used and that are not used anymore&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE IsNotUsedAnymore  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Namespaces where usage changed&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE IsUsedDifferently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Assemblies that were not used and that are now used&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE IsUsedRecently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Assemblies that were used and that are not used anymore&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE IsNotUsedAnymore  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Assemblies where usage changed&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE IsUsedDifferently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Fields that were not used and that are now used&lt;/Name&gt;\r\nSELECT FIELDS WHERE IsUsedRecently \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
					<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Tier Fields that were used and that are not used anymore&lt;/Name&gt;\r\nSELECT FIELDS WHERE IsNotUsedAnymore  \r\n\r\n// To run this query properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base</CQLQuery>
				</CQLGroup>
			</CQLGroup>
			<CQLGroup Name="Test Coverage of Changes Summary" Active="False">
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method changed 100% covered by tests&lt;/Name&gt;\r\nSELECT METHODS WHERE PercentageCoverage == 100 AND CodeWasChanged ORDER BY NbLinesOfCode DESC \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method added 100% covered by tests&lt;/Name&gt;\r\nSELECT METHODS WHERE WasAdded AND PercentageCoverage == 100 ORDER BY NbLinesOfCode DESC \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method changed partially covered by tests&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  PercentageCoverage &lt; 100 AND PercentageCoverage &gt; 0 AND\r\n  CodeWasChanged \r\n  ORDER BY PercentageCoverage DESC , NbLinesOfCodeCovered , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method added partially covered by tests&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  PercentageCoverage &lt; 100 AND PercentageCoverage &gt; 0 AND\r\n  WasAdded  \r\n  ORDER BY PercentageCoverage DESC , NbLinesOfCodeCovered , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method changed not covered at all&lt;/Name&gt;\r\nSELECT METHODS WHERE PercentageCoverage == 0 AND CodeWasChanged ORDER BY NbLinesOfCode DESC \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method added not covered at all&lt;/Name&gt;\r\nSELECT METHODS WHERE PercentageCoverage == 0 AND WasAdded ORDER BY NbLinesOfCode DESC \r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
			</CQLGroup>
		</CQLGroup>
		<CQLGroup Name="Test Coverage" Active="True">
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Coverage regression on methods 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\nHasAttribute "OPTIONAL:NDepend.CQL.FullCoveredAttribute" AND PercentageCoverage &lt; 100\r\n\r\n// NDepend.CQL.FullCoveredAttribute is defined in the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag '100% covered' methods.\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Coverage regression on methods 100% Branch-covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\nHasAttribute "OPTIONAL:NDepend.CQL.FullBranchCoveredAttribute" AND PercentageBranchCoverage &lt; 100\r\n\r\n// NDepend.CQL.FullCoveredAttribute is defined in the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag '100% branch covered' methods.\r\n\r\n// To run this constraint properly branch coverage data must be gathered from NCover™.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx\r\n\r\n// The metric BranchCoverage is not available if you are using Visual Studio™ Coverage.</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Coverage regression on type 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\nHasAttribute "OPTIONAL:NDepend.CQL.FullCoveredAttribute" AND PercentageCoverage &lt; 100\r\n\r\n// NDepend.CQL.FullCoveredAttribute is defined in the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag '100% covered' types.\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Coverage regression on assembly 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\nHasAttribute "OPTIONAL:NDepend.CQL.FullCoveredAttribute" AND PercentageCoverage &lt; 100\r\n\r\n// NDepend.CQL.FullCoveredAttribute is defined in the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag '100% covered' assemblies.\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Coverage regression on methods at least 95% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\nHasAttribute "OPTIONAL:NDepend.CQL.MoreThan95PercentCoveredAttribute" AND PercentageCoverage &lt; 95\r\n\r\n// NDepend.CQL.MoreThan95PercentCoveredAttribute is defined in the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag 'at least 95% Covered' methods.\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Coverage regression on types at least 95% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\nHasAttribute "OPTIONAL:NDepend.CQL.MoreThan95PercentCoveredAttribute" AND PercentageCoverage &lt; 95\r\n\r\n// NDepend.CQL.MoreThan95PercentCoveredAttribute is defined in the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag 'at least 95% Covered' types.\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Coverage regression on assemblies at least 95% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\nHasAttribute "OPTIONAL:NDepend.CQL.MoreThan95PercentCoveredAttribute" AND PercentageCoverage &lt; 95\r\n\r\n// NDepend.CQL.MoreThan95PercentCoveredAttribute is defined in the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag 'at least 95% Covered' assemblies.\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Complex methods should be 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS /*OUT OF "YourGeneratedCode" */ WHERE \r\n     // These metrics' definitions are available here: http://www.ndepend.com/Metrics.aspx#MetricsOnMethods\r\n     (  NbILInstructions &gt; 200 OR \r\n        ILCyclomaticComplexity &gt; 50 OR \r\n        ILNestingDepth &gt; 4 OR\r\n        NbParameters &gt; 5 OR \r\n        NbVariables &gt; 8 OR\r\n        NbOverloads &gt; 6 ) AND \r\n     !PercentageCoverage &lt; 100\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Complex methods should be 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS /*OUT OF "YourGeneratedCode" */ WHERE \r\n     // These metrics' definitions are available here: http://www.ndepend.com/Metrics.aspx#MetricsOnMethods\r\n     (  NbILInstructions &gt; 200 OR \r\n        ILCyclomaticComplexity &gt; 50 OR \r\n        ILNestingDepth &gt; 4 OR\r\n        NbParameters &gt; 5 OR \r\n        NbVariables &gt; 8 OR\r\n        NbOverloads &gt; 6 ) AND \r\n     !PercentageCoverage &lt; 100\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
			<CQLGroup Name="Test Coverage Summary" Active="False">
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods 100% covered&lt;/Name&gt;\r\nSELECT METHODS WHERE PercentageCoverage == 100\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types 100% covered&lt;/Name&gt;\r\nSELECT TYPES WHERE PercentageCoverage == 100\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces 100% covered&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE PercentageCoverage == 100\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies 100% covered&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE PercentageCoverage == 100\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods not covered&lt;/Name&gt;\r\nSELECT METHODS WHERE PercentageCoverage == 0\r\nORDER BY NbLinesOfCode DESC\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types not covered&lt;/Name&gt;\r\nSELECT TYPES WHERE PercentageCoverage == 0\r\nORDER BY NbLinesOfCode DESC\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces not covered&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE PercentageCoverage == 0\r\nORDER BY NbLinesOfCode DESC\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies not covered&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE PercentageCoverage == 0\r\nORDER BY NbLinesOfCode DESC\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods 95% to 99% covered&lt;/Name&gt;\r\nSELECT METHODS WHERE PercentageCoverage &gt;= 95 AND PercentageCoverage &lt;= 99 \r\nORDER BY NbLinesOfCode DESC , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types 95% to 99% covered&lt;/Name&gt;\r\nSELECT TYPES WHERE PercentageCoverage &gt;= 95 AND PercentageCoverage &lt;= 99 \r\nORDER BY NbLinesOfCode DESC , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces 95% to 99% covered&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE PercentageCoverage &gt;= 95 AND PercentageCoverage &lt;= 99 \r\nORDER BY NbLinesOfCode DESC , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies 95% to 99% covered&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE PercentageCoverage &gt;= 95 AND PercentageCoverage &lt;= 99 \r\nORDER BY NbLinesOfCode DESC , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods 70% to 94% covered&lt;/Name&gt;\r\nSELECT METHODS WHERE PercentageCoverage &gt;= 70 AND PercentageCoverage &lt;= 94\r\nORDER BY NbLinesOfCode DESC , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types 70% to 94% covered&lt;/Name&gt;\r\nSELECT TYPES WHERE PercentageCoverage &gt;= 70 AND PercentageCoverage &lt;= 94\r\nORDER BY NbLinesOfCode DESC , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces 70% to 94% covered&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE PercentageCoverage &gt;= 70 AND PercentageCoverage &lt;= 94\r\nORDER BY NbLinesOfCode DESC , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies 70% to 94% covered&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE PercentageCoverage &gt;= 70 AND PercentageCoverage &lt;= 94\r\nORDER BY NbLinesOfCode DESC , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods 1% to 69% covered&lt;/Name&gt;\r\nSELECT METHODS WHERE PercentageCoverage &gt;= 1 AND PercentageCoverage &lt;= 69\r\nORDER BY NbLinesOfCode DESC , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types 1% to 69% covered&lt;/Name&gt;\r\nSELECT TYPES WHERE PercentageCoverage &gt;= 1 AND PercentageCoverage &lt;= 69\r\nORDER BY NbLinesOfCode DESC , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces 1% to 69% covered&lt;/Name&gt;\r\nSELECT NAMESPACES WHERE PercentageCoverage &gt;= 1 AND PercentageCoverage &lt;= 69\r\nORDER BY NbLinesOfCode DESC , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Assemblies 1% to 69% covered&lt;/Name&gt;\r\nSELECT ASSEMBLIES WHERE PercentageCoverage &gt;= 1 AND PercentageCoverage &lt;= 69\r\nORDER BY NbLinesOfCode DESC , NbLinesOfCodeNotCovered \r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
			</CQLGroup>
		</CQLGroup>
		<CQLGroup Name="Purity / Immutability / Side-Effects" Active="True">
			<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Fields should be marked as ReadOnly when possible&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT FIELDS WHERE IsImmutable AND !IsInitOnly\r\n\r\n// A field that matches the condition IsImmutable is a field that is assigned only by constructors of its class.\r\n// For an instance field, this means its value will remain constant throught the lifetime of the object.\r\n// For a static field, this means its value will remain constant throught the lifetime of the program.\r\n// In both cases, such field can safely be marked with the C# readonly keyword (ReadOnly in VB.NET).\r\n\r\n// The condition IsInitOnly matches fields that are marked with the C# readonly keyword (ReadOnly in VB.NET).\r\n\r\n\r\n\r\n</CQLQuery>
			<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Structures should be immutable&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE IsStructure AND !IsImmutable AND !IsInFrameworkAssembly\r\n\r\n// It is deemed as a good practice to make your structure immutable.\r\n// An object is immutable if its state doesn’t change once the object has been created. \r\n// Consequently, a structure is immutable if its instances are immutable.\r\n// Immutable types naturally simplify code by limiting side-effects.\r\n// See some explanations on immutability and how NDepend supports it here:\r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/13/immutable-types-understand-them-and-use-them.aspx\r\n</CQLQuery>
			<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Regression on immutable types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE HasAttribute "OPTIONAL:NDepend.CQL.ImmutableAttribute" AND !IsImmutable\r\n\r\n// An object is immutable if its state doesn’t change once the object has been created. \r\n// Consequently, a class or a structure is immutable if its instances are immutable.\r\n// Immutable types naturally simplify code by limiting side-effects.\r\n// See some explanations on immutability and how NDepend supports it here:\r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/13/immutable-types-understand-them-and-use-them.aspx\r\n\r\n// NDepend.CQL.ImmutableAttribute is defined in the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag 'immutable' types.\r\n\r\n</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Regression on pure methods&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  HasAttribute "OPTIONAL:NDepend.CQL.PureAttribute" AND \r\n  ( ChangesObjectState OR ChangesTypeState ) AND\r\n  NbLinesOfCode &gt; 0\r\n\r\n// A method is pure if its execution doesn’t change the value of any instance or static field. \r\n// Pure methods naturally simplify code by limiting side-effects.\r\n// See some explanations on immutability / purity and how NDepend supports it here:\r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/13/immutable-types-understand-them-and-use-them.aspx\r\n\r\n// NDepend.CQL.PureAttribute is defined in the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag 'pure' methods.\r\n\r\n</CQLQuery>
			<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Missing usage of ImmutableAttribute&lt;/Name&gt;\r\nSELECT TYPES WHERE !HasAttribute "OPTIONAL:NDepend.CQL.ImmutableAttribute" AND IsImmutable\r\n\r\n// Types matched by this query are immutable but are not tagged with the ImmutableAttribute.\r\n// The benefit of tagging them with the ImmutableAttribute is that the constraint 'Regression on immutable types' \r\n// will warn when the immutability of a type gets broken.\r\n\r\n// NDepend.CQL.ImmutableAttribute is defined in the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag 'immutable' types.\r\n</CQLQuery>
			<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Missing usage of PureAttribute&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n  !HasAttribute "OPTIONAL:NDepend.CQL.PureAttribute" AND \r\n  !ChangesObjectState AND !ChangesTypeState AND\r\n  NbLinesOfCode &gt; 0\r\n\r\n// Methods matched by this query are pure but are not tagged with the PureAttribute.\r\n// The benefit of tagging them with the PureAttribute is that the constraint 'Regression on pure methods'\r\n// will warn when the purity of a method gets broken.\r\n\r\n// NDepend.CQL.PureAttribute is defined in the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll\r\n// You can define your own attribute to tag 'pure' methods.</CQLQuery>
		</CQLGroup>
		<CQLGroup Name="Naming Conventions" Active="True">
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Instance fields should be prefixed with a 'm_'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n  !NameLike "^m_" AND \r\n  !IsStatic AND \r\n  !IsLiteral AND \r\n  !IsGeneratedByCompiler  AND \r\n  !IsSpecialName AND \r\n  !IsEventDelegateObject \r\n\r\n// This naming convention provokes debate.\r\n// Don't hesitate to customize the regex of NameLike to your preference.</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Static fields should be prefixed with a 's_'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n  !NameLike "^s_" AND \r\n  IsStatic AND \r\n  !IsLiteral AND \r\n  !IsGeneratedByCompiler AND \r\n  !IsSpecialName AND \r\n  !IsEventDelegateObject  \r\n\r\n// This naming convention provokes debate.\r\n// Don't hesitate to customize the regex of NameLike to your preference.\r\n</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Interface name should begin with a 'I'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE IsInterface AND !NameLike "^I" AND !IsNested AND !IsInFrameworkAssembly\r\n</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Abstract base class should be suffixed with 'Base'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  IsAbstract AND \r\n  IsClass AND\r\n  DepthOfInheritance == 1 AND // equivalent to:   DepthOfDeriveFrom "System.Object" == 1\r\n  !NameLike "Base$"\r\n</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Exception class name should be suffixed with 'Exception'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE IsExceptionClass AND !NameLike "Exception$" AND !IsInFrameworkAssembly\r\n// The name of an exception class should end with 'Exception'.</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Attribute class name should be suffixed with 'Attribute'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE IsAttributeClass AND !NameLike "Attribute$" AND !IsInFrameworkAssembly\r\n</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types name should begin with an Upper character&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n !NameLike "^[A-Z]" AND     // The name of a type should begin with an Upper letter.\r\n !IsGeneratedByCompiler AND // Except if it is generated by compiler or ...\r\n !IsInFrameworkAssembly     // ... if it is declared in a framework assembly.</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Methods name should begin with an Upper character&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n !NameLike "^[A-Z]" AND \r\n !(IsClassConstructor OR IsConstructor OR \r\n IsPropertyGetter  OR IsPropertySetter OR\r\n IsIndexerGetter OR IsIndexerSetter OR\r\n IsEventAdder OR IsEventRemover OR\r\n IsOperator) AND !IsGeneratedByCompiler AND !IsInFrameworkAssembly\r\n// The name of a regular method should begin with an Upper letter.</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Do not name enum values 'Reserved'&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE IsEnumValue AND NameLike "Reserved"\r\n\r\n// This rule assumes that an enumeration member with a name that contains "reserved" \r\n// is not currently used but is a placeholder to be renamed or removed in a future version.\r\n// Renaming or removing a member is a breaking change. You should not expect users to ignore\r\n// a member just because its name contains "reserved" nor can you rely on users to read or \r\n// abide by documentation. Furthermore, because reserved members appear in object browsers \r\n// and smart integrated development environments, they can cause confusion as to which members \r\n// are actually being used.\r\n\r\n// Instead of using a reserved member, add a new member to the enumeration in the future version.\r\n// In most cases, the addition of the new member is not a breaking change, as long as the \r\n// addition does not cause the values of the original members to change.</CQLQuery>
			<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Type names should not match namespaces&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  NameIs "Collections" OR\r\n  NameIs "Forms" OR\r\n  NameIs "System" OR\r\n  NameIs "UI"\r\n\r\n// Type names should not match the names of namespaces defined in the .NET Framework \r\n// class library. Violating this rule can reduce the usability of the library.</CQLQuery>
			<CQLGroup Name="Name too long" Active="True">
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Avoid methods with name too long&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS \r\n  WHERE NameLike "^[^\&lt;\(]{35,}.*$" AND \r\n        !IsExplicitInterfaceImpl AND !IsInFrameworkAssembly \r\n// The regex matches methods with name longer than 35 characters.\r\n// Method Name doesn't contain the type and namespace prefix, FullName does.\r\n// The regex computes the method name length from the beginning until the first open parenthesis or first lower than (for generic methods).\r\n// Explicit Interface Implementation methods are discarded because their names are prefixed with the interface name.</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Avoid types with name too long&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n  NameLike "^[^\&lt;]{35,}.*$" AND \r\n  !IsNested AND !IsInFrameworkAssembly \r\n// The regex matches types with name longer than 35 characters.\r\n// Type Name doesn't contain the namespace prefix, FullName does.\r\n// The regex computes the type name length from the beginning until the end or the first lower than (for generic types).\r\n// Nested types are discarded because their names are prefixed with outer type's name.</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Avoid fields with name too long&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 FIELDS WHERE \r\n  NameLike "^[^\&lt;]{35,}.*$" AND \r\n  !IsInFrameworkAssembly \r\n// The regex matches fields with name longer than 35 characters.\r\n// Field Name doesn't contain the type and namespace prefix, FullName does.</CQLQuery>
			</CQLGroup>
		</CQLGroup>
		<CQLGroup Name=".NET Framework Usage" Active="True">
			<CQLGroup Name="System" Active="True">
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Mark ISerializable types with serializable&lt;/Name&gt;\r\nSELECT TYPES WHERE \r\n IsPublic AND !IsDelegate AND\r\n Implement "OPTIONAL:System.Runtime.Serialization.ISerializable" AND \r\n !HasAttribute "OPTIONAL:System.SerializableAttribute"\r\n\r\n// To be recognized by the CLR as serializable, types must be marked with the SerializableAttribute \r\n// attribute even if the type uses a custom serialization routine through implementation of the ISerializable interface.</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Mark assemblies with assembly version&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  !HasAttribute "OPTIONAL:System.Reflection.AssemblyVersionAttribute" AND\r\n  !IsFrameworkAssembly \r\n\r\n// The identity of an assembly is composed of the following information:\r\n//    - Assembly name\r\n//    - Version number\r\n//    - Culture\r\n//    - Public key (for strong-named assemblies).\r\n// The .NET Framework uses the version number to uniquely identify an assembly, \r\n// and to bind to types in strong-named assemblies. The version number is used \r\n// together with version and publisher policy. By default, applications run only \r\n// with the assembly version with which they were built.</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Mark assemblies with CLSCompliant&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  !HasAttribute "OPTIONAL:System.CLSCompliantAttribute" AND\r\n  !IsFrameworkAssembly \r\n\r\n// The Common Language Specification (CLS) defines naming restrictions, data types, \r\n// and rules to which assemblies must conform if they are to be used across programming languages.\r\n// Good design dictates that all assemblies explicitly indicate CLS compliance with \r\n// CLSCompliantAttribute. If the attribute is not present on an assembly, the assembly is not compliant.</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Mark assemblies with ComVisible&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  !HasAttribute "OPTIONAL:System.Runtime.InteropServices.ComVisibleAttribute" AND\r\n  !IsFrameworkAssembly \r\n\r\n// The ComVisibleAttribute attribute determines how COM clients access managed code. \r\n// Good design dictates that assemblies explicitly indicate COM visibility. \r\n// COM visibility can be set for an entire assembly and then overridden for individual \r\n// types and type members. If the attribute is not present, the contents of the assembly\r\n// are visible to COM clients.</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Mark attributes with AttributeUsageAttribute&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\nDeriveFrom "OPTIONAL:System.Attribute" AND\r\n!HasAttribute "OPTIONAL:System.AttributeUsageAttribute" AND\r\n!IsInFrameworkAssembly \r\n\r\n// When defining a custom attribute, mark it using AttributeUsageAttribute to \r\n// indicate where in the source code the custom attribute can be applied.\r\n// An attribute's meaning and intended usage will determine its valid locations \r\n// in code. For example, if you are defining an attribute that identifies the \r\n// person responsible for maintaining and enhancing each type in a library, \r\n// and responsibility is always assigned at the type level, compilers should \r\n// allow the attribute on classes, enumerations, and interfaces, but should \r\n// not allow it on methods, events, or properties. Organizational policies and\r\n// procedures would dictate whether the attribute should be allowed on assemblies.</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Remove calls to GC.Collect()&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  IsDirectlyUsing "OPTIONAL:System.GC.Collect()" OR\r\n  IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32)" OR\r\n  IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32,GCCollectionMode)"\r\n\r\n// It is preferrable to avoid calling GC.Collect() explicitely\r\n// in order to avoid some performance pitfall.\r\n// More in information on this here:\r\n// http://blogs.msdn.com/ricom/archive/2004/11/29/271829.aspx</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Don't call GC.Collect() without calling GC.WaitForPendingFinalizers()&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  (IsDirectlyUsing "OPTIONAL:System.GC.Collect()" OR\r\n   IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32)" OR\r\n   IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32,GCCollectionMode)") \r\n  AND\r\n  !IsDirectlyUsing "OPTIONAL:System.GC.WaitForPendingFinalizers()" \r\n\r\n// It is preferrable to avoid calling GC.Collect() explicitely\r\n// in order to avoid some performance pitfall.\r\n// But if you wish to call GC.Collect(), you must do it this way:\r\n//   GC.Collect();\r\n//   GC.WaitForPendingFinalizers();\r\n//   GC.Collect();\r\n// To make sure that finalizer got executed, and object with finalizer got cleaned properly.</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Enum Storage should be Int32&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT FIELDS WHERE \r\n  NameIs "value__" AND \r\n  !IsOfType "OPTIONAL:System.Int32" AND\r\n  !IsInFrameworkAssembly\r\n\r\n// An enumeration is a value type that defines a set of related named constants. By default, \r\n// the System.Int32 data type is used to store the constant value. Even though you can change \r\n// this underlying type, it is not necessary or recommended for most scenarios. Note that there \r\n// is no significant performance gain in using a data type smaller than Int32. If you cannot \r\n// use the default data type, you should use one of the CLS-compliant integral types, Byte, \r\n// Int16, Int32, or Int64, to ensure that all of the enumeration's values are representable in \r\n// CLS-compliant programming languages.</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Do not raise too general exception types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  // The following exception types are too general to provide sufficient information to the user:\r\n  ( ( DepthOfCreateA "OPTIONAL:System.Exception" == 1 OR \r\n      DepthOfCreateA "OPTIONAL:System.ApplicationException" == 1 OR \r\n      DepthOfCreateA "OPTIONAL:System.SystemException" == 1 )\r\n    // Test for non-constructor, else this constraint would warn \r\n    // on ctor of classes that derive from these exception types.\r\n    AND !IsConstructor )\r\n</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Do not raise reserved exception types&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  // The following exception types are reserved and should be thrown only by the Common Language Runtime:\r\n  ( DepthOfCreateA "OPTIONAL:System.ExecutionEngineException" == 1 OR \r\n    DepthOfCreateA "OPTIONAL:System.IndexOutOfRangeException" == 1 OR \r\n    DepthOfCreateA "OPTIONAL:System.NullReferenceException" == 1 OR\r\n    DepthOfCreateA "OPTIONAL:System.OutOfMemoryException" == 1 OR\r\n    DepthOfCreateA "OPTIONAL:System.StackOverflowException" == 1 OR \r\n    DepthOfCreateA "OPTIONAL:System.InvalidProgramException" == 1 OR \r\n    DepthOfCreateA "OPTIONAL:System.AccessViolationException" == 1 OR\r\n    DepthOfCreateA "OPTIONAL:System.CannotUnloadAppDomainException" == 1 OR\r\n    DepthOfCreateA "OPTIONAL:System.BadImageFormatException" == 1 OR \r\n    DepthOfCreateA "OPTIONAL:System.DataMisalignedException" == 1 )\r\n</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Use integral or string argument for indexers&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\nIsIndexerGetter AND \r\n !( NameIs "get_Item(String)" OR \r\n    NameLike "get_Item\(Int" OR \r\n    NameLike "get_Item\(Byte" OR\r\n    NameLike "get_Item\(SByte" )\r\n\r\n// Indexers, that is, indexed properties, should use integer or string types for the index. \r\n// These types are typically used for indexing data structures and increase the usability of \r\n// the library. Use of the Object type should be restricted to those cases where the specific \r\n// integer or string type cannot be specified at design time. If the design requires other \r\n// types for the index, reconsider whether the type represents a logical data store. If it \r\n// does not represent a logical data store, use a method.</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Uri fields should be of type System.Uri&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT FIELDS WHERE \r\n  (NameLike "Uri$" OR NameLike "Url$") AND !IsOfType "OPTIONAL:System.Uri"\r\n\r\n// A field which name end with 'Uri' is deemed as representing a uri.\r\n// Such field should be of type System.Uri.</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types should not extend System.ApplicationException&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE\r\n  DepthOfDeriveFrom "OPTIONAL:System.ApplicationException" == 1 AND\r\n  !IsInFrameworkAssembly\r\n\r\n// For .NET Framework version 1, it was recommended to derive new exceptions from ApplicationException. \r\n// The recommendation has changed and new exceptions should derive from System.Exception or one of its \r\n// subclasses in the System namespace.</CQLQuery>
			</CQLGroup>
			<CQLGroup Name="System.Collection" Active="True">
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Don't use .NET 1.x HashTable and ArrayList&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE\r\n\r\n // Prefer using the class System.Collections.Generic.Dictionary&lt;K,V&gt; over System.Collections.HashTable.\r\n CreateA "OPTIONAL:System.Collections.HashTable" OR\r\n\r\n // Prefer using the class System.Collections.Generic.List&lt;T&gt; over System.Collections.ArrayList.\r\n CreateA "OPTIONAL:System.Collections.ArrayList"\r\n\r\n// You can be forced to use HashTable or ArrayList \r\n// because if you are using tier code that requires working with these classes\r\n// or because you are coding with .NET 1.x.</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Caution with List.Contains()&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\nIsDirectlyUsing "OPTIONAL:System.Collections.Generic.List&lt;T&gt;.Contains(T)" OR\r\nIsDirectlyUsing "OPTIONAL:System.Collections.Generic.IList&lt;T&gt;.Contains(T)" OR\r\nIsDirectlyUsing "OPTIONAL:System.Collections.ArrayList.Contains(Object)"\r\n\r\n// The cost of checking if a list contains an object is proportional to the size of the list (O(N) operation).\r\n// For large lists and/or frequent calls to Contains(), prefer using the System.Collections.Generic.HashSet&lt;T&gt; class \r\n// where calls to Contains() takes a constant time (O(0) operation).</CQLQuery>
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Prefer return collection abstraction instead of implementation&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n ReturnTypeIs "OPTIONAL:System.Collections.Generic.List&lt;T&gt;" OR \r\n ReturnTypeIs "OPTIONAL:System.Collections.Generic.HashSet&lt;T&gt;" OR\r\n ReturnTypeIs "OPTIONAL:System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;"\r\n\r\n// Most of the time, clients of a method doesn't need to know the exact implementation of the collection returned.\r\n// It is preferrable to return a collection interface such as IList&lt;T&gt;, ICollection&lt;T&gt; or IEnumerable&lt;T&gt;.</CQLQuery>
			</CQLGroup>
			<CQLGroup Name="System.Runtime.InteropServices" Active="True">
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;P/Invokes should be static and not be visible&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  !IsInFrameworkAssembly AND\r\n  (HasAttribute "OPTIONAL:System.Runtime.InteropServices.DllImportAttribute") AND\r\n  ( IsPublic OR \r\n    !IsStatic)\r\n\r\n// Methods marked with the DllImportAttribute attribute (or methods defined using the \r\n// Declare keyword in Visual Basic) use Platform Invocation Services to access unmanaged \r\n// code. Such methods should not be exposed. Keeping these methods private or internal \r\n// ensures that your library cannot be used to breach security by allowing callers access \r\n// to unmanaged APIs they could not call otherwise.</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Move P/Invokes to NativeMethods class&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  !IsInFrameworkAssembly AND\r\n  HasAttribute "OPTIONAL:System.Runtime.InteropServices.DllImportAttribute" AND\r\n  !FullNameLike "NativeMethods."\r\n\r\n// Platform Invocation methods, such as those marked with the System.Runtime.InteropServices.DllImportAttribute \r\n// attribute, or methods defined by using the Declare keyword in Visual Basic, access unmanaged code. \r\n// These methods should be in one of the following classes:\r\n//\r\n//     - NativeMethods - This class does not suppress stack walks for unmanaged code permission. \r\n//       (System.Security.SuppressUnmanagedCodeSecurityAttribute must not be applied to this class.) \r\n//       This class is for methods that can be used anywhere because a stack walk will be performed.\r\n//\r\n//     - SafeNativeMethods - This class suppresses stack walks for unmanaged code permission. \r\n//       (System.Security.SuppressUnmanagedCodeSecurityAttribute is applied to this class.) \r\n//       This class is for methods that are safe for anyone to call. Callers of these methods are not \r\n//       required to do a full security review to ensure that the usage is secure because the methods\r\n//       are harmless for any caller.\r\n//\r\n//     - UnsafeNativeMethods - This class suppresses stack walks for unmanaged code permission. \r\n//       (System.Security.SuppressUnmanagedCodeSecurityAttribute is applied to this class.) \r\n//       This class is for methods that are potentially dangerous. Any caller of these methods must do\r\n//       a full security review to ensure that the usage is secure because no stack walk will be performed.\r\n</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;NativeMethods class should be static and internal&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE\r\n  !IsInFrameworkAssembly AND\r\n  ( NameIs "NativeMethods" OR\r\n    NameIs "SafeNativeMethods" OR\r\n    NameIs "UnsafeNativeMethods") AND\r\n  IsPublic OR\r\n  !IsStatic \r\n\r\n// Native Methods' classes are declared as internal (Friend, in Visual Basic) and static.\r\n</CQLQuery>
			</CQLGroup>
			<CQLGroup Name="System.Threading" Active="True">
				<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Method non-synchronized that read mutable states&lt;/Name&gt;\r\nSELECT METHODS WHERE \r\n (ReadsMutableObjectState OR ReadsMutableTypeState) AND \r\n !IsDirectlyUsing "OPTIONAL:System.Threading.Monitor" AND \r\n !IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock"\r\n\r\n// Mutable object states are instance fields that can be modifed throught the lifetime of the object.\r\n// Mutable type states are static fields that can be modifed throught the lifetime of the program.\r\n// This query lists methods that read mutable state without synchronizing access.\r\n// In the case of multi-threaded program, doing so can lead to state corruption.</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Don't create threads explicitely&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  CreateA "OPTIONAL:System.Threading.Thread"\r\n\r\n// Prefer using the thread pool instead of creating manually your own thread.\r\n// Threads are costly objects. \r\n// They take approximately 200,000 cycles to create and about 100,000 cycles to destroy.  \r\n// By default they reserve 1 megabyte of virtual memory for its stack and use 2,000-8,000 cycles for each context switch.\r\n// As a consequence, it is preferrable to let the thread pool recycle threads.\r\n\r\n// Creating custom thread can also be the sign of flawed design, where tasks and threads have affinity.\r\n// It is preferrable to code tasks that can be ran on any thread.</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Don't use Thread.Sleep()&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE IsDirectlyUsing  "OPTIONAL:System.Threading.Thread.Sleep(Int32)"\r\n\r\n// Usage of Thread.Sleep() is a sign of flawed design.\r\n// More information on this here:\r\n// http://msmvps.com/blogs/peterritchie/archive/2007/04/26/thread-sleep-is-a-sign-of-a-poorly-designed-program.aspx\r\n</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Don't use Thread.Abort()&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  IsDirectlyUsing  "OPTIONAL:System.Threading.Thread.Abort()" OR\r\n  IsDirectlyUsing  "OPTIONAL:System.Threading.Thread.Abort(Object)" \r\n\r\n// Usage of Thread.Abort() is dangerous.\r\n// More information on this here:\r\n// http://www.interact-sw.co.uk/iangblog/2004/11/12/cancellation</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Monitor Enter/Exit must be both called within the same method&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.Enter(Object)" AND\r\n !IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.Exit(Object)" </CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Monitor TryEnter/Exit must be both called within the same method&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n ( IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.Enter(Object)" OR\r\n   IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.TryEnter(Object,Int32)" OR\r\n   IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.TryEnter(Object,TimeSpan)") AND\r\n !IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.Exit(Object)" </CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;ReaderWriterLock AcquireReaderLock/ReleaseLock must be both called within the same method&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  ( IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.TryEnter(Object,TimeSpan)") \r\nAND\r\n !( IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.ReleaseReaderLock()" OR \r\n    IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.ReleaseLock()") </CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;ReaderWriterLock AcquireWriterLock/ReleaseLock must be both called within the same method&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE\r\n  ( IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.TryEnter(Object,TimeSpan)") \r\nAND\r\n !( IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.ReleaseWriterLock()" OR \r\n    IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.ReleaseLock()") </CQLQuery>
			</CQLGroup>
			<CQLGroup Name="System.Xml" Active="True">
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Method should not return concrete XmlNode&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n( ReturnTypeIs "OPTIONAL:System.Xml.XmlDocument" OR \r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlAttribute" OR \r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlDocumentFragment" OR \r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlEntity" OR \r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlLinkedNode" OR \r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlNotation" OR\r\n  ReturnTypeIs "OPTIONAL:System.Xml.XmlNode" )\r\n\r\n// The class System.Xml.XmlNode implements the interface System.Xml.Xpath.IXPathNavigable.\r\n// It is preferrable to return this interface instead of a concrete class.\r\n</CQLQuery>
				<CQLQuery Active="True" DisplayList="False" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Types should not extend System.Xml.XmlDocument&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE DepthOfDeriveFrom "OPTIONAL:System.Xml.XmlDocument" == 1\r\n\r\n// Do not create a subclass of XmlDocument if you want to create an XML view of an underlying object model or data source.</CQLQuery>
			</CQLGroup>
		</CQLGroup>
		<CQLGroup Name="Statistics" Active="False">
			<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Most used types (TypeRank)&lt;/Name&gt;\r\nSELECT TOP 50 TYPES ORDER BY TypeRank DESC\r\n// TypeRank values are computed by applying the Google PageRank \r\n// algorithm on the graph of types' dependencies \r\n// Types with high Rank are the most used ones.\r\n// See the definition of the TypeRank metric here http://www.ndepend.com/Metrics.aspx#TypeRank</CQLQuery>
			<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Most used methods (MethodRank)&lt;/Name&gt;\r\nSELECT TOP 50 METHODS ORDER BY MethodRank DESC\r\n// MethodRank values are computed by applying the Google PageRank \r\n// algorithm on the graph of methods' dependencies\r\n// Methods with high Rank are the most used ones.\r\n// See the definition of the MethodRank metric here http://www.ndepend.com/Metrics.aspx#MethodRank</CQLQuery>
			<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Most used namespaces (NamespaceCa)&lt;/Name&gt;\r\nSELECT TOP 50 NAMESPACES ORDER BY NamespaceCa DESC\r\n// The Afferent Coupling for a particular namespace is the number of namespaces that depends directly on it.\r\n// Namespaces with high Ca are the most used ones.\r\n// See the definition of the NamespaceCa metric here http://www.ndepend.com/Metrics.aspx#NamespaceCa</CQLQuery>
			<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Most used types  (TypeCa)&lt;/Name&gt;\r\nSELECT TOP 50 TYPES ORDER BY TypeCa DESC\r\n// The Afferent Coupling for a particular type is the number of types that depends directly on it.\r\n// Types with high Ca are the most used ones.\r\n// See the definition of the TypeCa metric here http://www.ndepend.com/Metrics.aspx#TypeCa</CQLQuery>
			<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Most used methods (MethodCa)&lt;/Name&gt;\r\nSELECT TOP 50 METHODS ORDER BY MethodCa DESC\r\n// The Afferent Coupling for a particular method is the number of methods that depends directly on it.\r\n// Methods with high Ca are the most used ones\r\n// See the definition of the MethodCa metric here http://www.ndepend.com/Metrics.aspx#MethodCa</CQLQuery>
			<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Namespaces that use many other namespaces (NamespaceCe)&lt;/Name&gt;\r\nSELECT TOP 50 NAMESPACES ORDER BY NamespaceCe DESC\r\n// The Efferent Coupling for a particular namespace is the number of namespaces it directly depends on.\r\n// Namespaces declared in Framework assemblies are taken account.\r\n// See the definition of the NamespaceCe metric here http://www.ndepend.com/Metrics.aspx#NamespaceCe</CQLQuery>
			<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Types that use many other types (TypeCe)&lt;/Name&gt;\r\nSELECT TOP 50 TYPES ORDER BY TypeCe DESC\r\n// The Efferent Coupling for a particular type is the number of types it directly depends on.\r\n// Types declared in Framework assemblies are taken account.\r\n// See the definition of the TypeCe metric here http://www.ndepend.com/Metrics.aspx#TypeCe</CQLQuery>
			<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;Methods that use many other methods (MethodCe)&lt;/Name&gt;\r\nSELECT TOP 50 METHODS ORDER BY MethodCe DESC\r\n// The Efferent Coupling for a particular method is the number of methods it directly depends on.\r\n// Methods declared in Framework assemblies are taken account.\r\n// See the definition of the MethodCe metric here http://www.ndepend.com/Metrics.aspx#MethodCe</CQLQuery>
			<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;High-level to low-level assemblies (AssemblyLevel)&lt;/Name&gt;\r\nSELECT ASSEMBLIES ORDER BY AssemblyLevel DESC\r\n// Classify assemblies by their Level values.\r\n// See the definition of the AssemblyLevel metric here http://www.ndepend.com/Metrics.aspx#Level</CQLQuery>
			<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;High-level to low-level namespaces (NamespaceLevel)&lt;/Name&gt;\r\nSELECT NAMESPACES ORDER BY NamespaceLevel DESC\r\n// Classify namespaces by their Level values.\r\n// See the definition of the NamespaceLevel metric here http://www.ndepend.com/Metrics.aspx#Level</CQLQuery>
			<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;High-level to low-level types (TypeLevel)&lt;/Name&gt;\r\nSELECT TYPES ORDER BY TypeLevel DESC\r\n// Classify types by their Level values.\r\n// See the definition of the TypeLevel metric here http://www.ndepend.com/Metrics.aspx#Level</CQLQuery>
			<CQLQuery Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False">// &lt;Name&gt;High-level to low-level methods (MethodLevel)&lt;/Name&gt;\r\nSELECT METHODS ORDER BY MethodLevel DESC\r\n// Classify methods by their Level values.\r\n// See the definition of the MethodLevel metric here http://www.ndepend.com/Metrics.aspx#Level</CQLQuery>
		</CQLGroup>
		<CQLGroup Name="Samples of Custom Constraints" Active="False">
			<CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the assembly Asm1 is not using the assembly Asm2&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  IsDirectlyUsing "OPTIONAL:ASSEMBLY:Asm2" AND\r\n  NameIs "Asm1"\r\n  // The OPTIONAL: prefix is just use to avoid an error because there is currently no assembly named Asm2.\r\n</CQLQuery>
			<CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the namespace N1.N2 is not using the namespace N3.N4.N5&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT NAMESPACES WHERE \r\n  IsDirectlyUsing "OPTIONAL:ASSEMBLY:N3.N4.N5" AND\r\n  NameIs "N1.N2"\r\n  // The OPTIONAL: prefix is just use to avoid an error because there is currently no namespace named N3.N4.N5.\r\n</CQLQuery>
			<CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the assembly Asm1 is only using the assemblies Asm2, Asm3 or mscorlib&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  ( !IsDirectlyUsing "OPTIONAL:ASSEMBLY:Asm2" OR\r\n    !IsDirectlyUsing "OPTIONAL:ASSEMBLY:Asm3" OR\r\n    !IsDirectlyUsing "ASSEMBLY:mscorlib" OR\r\n    AsmCe != 3) // Must not be used more than 3 assemblies \r\n                // AsmCe = Efferent Coupling for assembly\r\nAND \r\n  NameIs "Asm1"\r\n  // The OPTIONAL: prefix is just use to avoid an error because there is currently no assembly named Asm2 or Asm3.\r\n</CQLQuery>
			<CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the namespace N1.N2 is only using the namespaces N3.N4, N5 or System&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  ( !IsDirectlyUsing "OPTIONAL:NAMESPACE:N3.N4" OR\r\n    !IsDirectlyUsing "OPTIONAL:NAMESPACE:N5" OR\r\n    !IsDirectlyUsing "NAMESPACE:System" OR\r\n    AsmCe != 3) // Must not be used more than 3 assemblies \r\n                // AsmCe = Efferent Coupling for assembly\r\nAND \r\n  NameIs "Asm1"\r\n  // The OPTIONAL: prefix is just use to avoid an error because there is currently no namespace named N3.N4 or N5.\r\n</CQLQuery>
			<CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that AsmDrawing is the only assembly that is using System.Drawing&lt;/Name&gt;\r\nWARN IF Count&gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  IsDirectlyUsing "OPTIONAL:ASSEMBLY:System.Drawing" AND\r\n  !NameIs "AsmDrawing"\r\n\r\n// The OPTIONAL: prefix is just use to avoid an error because System.Drawing might not be currently referenced.\r\n</CQLQuery>
			<CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that only 3 assemblies are using System.Drawing&lt;/Name&gt;\r\nWARN IF Count &gt; 3 IN SELECT ASSEMBLIES WHERE \r\n  IsDirectlyUsing "OPTIONAL:ASSEMBLY:System.Drawing"\r\n\r\n// The OPTIONAL: prefix is just use to avoid an error because System.Drawing might not be currently referenced.\r\n</CQLQuery>
			<CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that all methods that call Foo.Fct1() also call Foo.Fct2(Int32)&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n  IsDirectlyUsing "OPTIONAL:Foo.Fct1()" AND\r\n  !IsDirectlyUsing "OPTIONAL:Foo.Fct2(Int32)"\r\n  // The OPTIONAL: prefix is just use to avoid an error because there is currently no methods named Foo.Fct1() or Foo.Fct2(Int32)</CQLQuery>
			<CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that all types that derive from Foo, also implement IFoo&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\n  DeriveFrom "OPTIONAL:TYPE:Foo" AND\r\n  !Implement "OPTIONAL:TYPE:IFoo"\r\n  // The OPTIONAL: prefix is just use to avoid an error because there is currently no class named Foo and no interface named IFoo</CQLQuery>
			<CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that all types that has the attribute FooAttribute are declared in the namespace N1.N2&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT TYPES \r\n  OUT OF NAMESPACES "OPTIONAL:N1.N2" \r\n  WHERE \r\n    HasAttribute "OPTIONAL:FooAttribute"\r\n\r\n  // The OPTIONAL: prefix is just use to avoid an error because there is currently no attribute class named FooAttribute and no namespace named N1.N2</CQLQuery>
			<CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that all synchronization objects are only used from the namespaces under MyNamespace.Sync&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT NAMESPACES \r\n  WHERE \r\n    IsDirectlyUsing "OPTIONAL:System.Threading.Monitor" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.Mutex" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.EventWaitHandle" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.Semaphore" OR\r\n    IsDirectlyUsing "OPTIONAL:System.Threading.Interlocked" \r\n  AND !NameLike "^MyNamespace.Sync"\r\n\r\n  // The OPTIONAL: prefix is just use to avoid an error because there some code elemnts might not currently exists.</CQLQuery>
			<CQLQuery Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the graph of namespaces dependencies of the assembly Asm is acyclic&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\n  NameIs "OPTIONAL:Asm" AND\r\n  ContainsNamespaceDependencyCycle\r\n  // The OPTIONAL: prefix is just use to avoid an error because there is currently no assembly named Asm</CQLQuery>
			<CQLGroup Name="Check that the Quality is respected from Now!" Active="True">
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;From now, all methods added or refactored should respect basic quality principles&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 METHODS WHERE \r\n\r\n                                           // Metrics' definitions\r\n     (  NbLinesOfCode &gt; 30 OR              // http://www.ndepend.com/Metrics.aspx#NbLinesOfCode\r\n        NbILInstructions &gt; 200 OR          // http://www.ndepend.com/Metrics.aspx#NbILInstructions\r\n        CyclomaticComplexity &gt; 20 OR       // http://www.ndepend.com/Metrics.aspx#CC\r\n        ILCyclomaticComplexity &gt; 50 OR     // http://www.ndepend.com/Metrics.aspx#ILCC\r\n        ILNestingDepth &gt; 4 OR              // http://www.ndepend.com/Metrics.aspx#ILNestingDepth\r\n        NbParameters &gt; 5 OR                // http://www.ndepend.com/Metrics.aspx#NbParameters\r\n        NbVariables &gt; 8 OR                 // http://www.ndepend.com/Metrics.aspx#NbVariables\r\n        NbOverloads &gt; 6 )                  // http://www.ndepend.com/Metrics.aspx#NbOverloads\r\n\r\n     AND (WasAdded OR CodeWasChanged)\r\n\r\n// This constraint warns if a method with low-quality has been added or refactored.\r\n// With NDepend and such constraint, you can Ensure Quality From Now! as explained here:\r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/01/ensure-the-quality-of-the-code-that-will-be-developed-this-year.aspx\r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in VisualNDepend throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Analysis Comparison</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;From now, all types added or refactored should respect basic quality principles&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n     // These metrics' definitions are available here: http://www.ndepend.com/Metrics.aspx#MetricsOnMethods\r\n     (  NbMethods &gt; 20 OR\r\n        (NbFields &gt; 20 AND !IsEnumeration) OR\r\n        (LCOMHS &gt; 0.95 AND NbFields &gt; 10 AND NbMethods &gt; 10) OR\r\n        TypeCe &gt; 50  ) \r\n     AND (WasAdded OR CodeWasChanged)\r\n\r\n// This constraint warns if a type with low-quality has been added or refactored.\r\n// With NDepend and such constraint, you can Ensure Quality From Now! as explained here:\r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/01/ensure-the-quality-of-the-code-that-will-be-developed-this-year.aspx\r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in VisualNDepend throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Analysis Comparison</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;From now, all methods added or refactored should be 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TOP 10 TYPES WHERE \r\n     // These metrics' definitions are available here: http://www.ndepend.com/Metrics.aspx#MetricsOnMethods\r\n     PercentageCoverage &lt; 100\r\n     AND (WasAdded OR CodeWasChanged)\r\n\r\n// This constraint warns if a method has been added or refactored and hasn't been 100% covered by tests.\r\n// With NDepend and such constraint, you can Ensure Quality From Now! as explained here:\r\n// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/01/ensure-the-quality-of-the-code-that-will-be-developed-this-year.aspx\r\n\r\n// To run this constraint properly 2 analysis must be compared.\r\n// This can be done in VisualNDepend throught the menu: Start Page -&gt; Compare 2 versions of a code base\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Analysis Comparison\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx</CQLQuery>
			</CQLGroup>
			<CQLGroup Name="Check Coverage on particular Code Elements" Active="True">
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the assembly Asm is 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE \r\nNameIs "Asm" AND PercentageCoverage &lt; 100\r\n\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx\r\n\r\n</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the namespace N1.N2 is 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT NAMESPACES WHERE \r\nNameIs "N1.N2" AND PercentageCoverage &lt; 100\r\n\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx\r\n\r\n</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the class Namespace.Foo is 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\nFullNameIs "Namespace.Foo" AND PercentageCoverage &lt; 100\r\n\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx\r\n\r\n</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that the class Namespace.Foo.Method(Int32) is 100% covered by tests&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\nFullNameIs "Namespace.Foo.Method(Int32)" AND PercentageCoverage &lt; 100\r\n\r\n\r\n// To run this constraint properly coverage data must be gathered from NCover™ or Visual Studio™ Coverage.\r\n// This can be done in VisualNDepend throught the menu: Coverage -&gt; Import Coverage Files\r\n// This can be done at analysis time throught the menu: Project Properties -&gt; Analysis -&gt; Code Coverage\r\n// More information on how to import coverage data here:\r\n// http://www.ndepend.com/Coverage.aspx\r\n\r\n</CQLQuery>
			</CQLGroup>
			<CQLGroup Name="Custom Naming Conventions" Active="True">
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that all types that derive from Foo, has a name that ends up with Foo&lt;/Name&gt;\r\n\r\nWARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\n  DeriveFrom "OPTIONAL:TYPE:Foo" AND\r\n  !NameLike "Foo$"\r\n  // The OPTIONAL: prefix is just use to avoid an error because there is currently no class named Foo</CQLQuery>
				<CQLQuery Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False">// &lt;Name&gt;Check that all namespaces begins with CompanyName.ProductName&lt;/Name&gt;\r\nWARN IF Count &gt; 0 IN SELECT NAMESPACES WHERE \r\n  !NameLike "^CompanyName.ProductName"\r\n  AND !IsInFrameworkAssembly </CQLQuery>
			</CQLGroup>
		</CQLGroup>
	</CQLQueries>
</NDepend>
